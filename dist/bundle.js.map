{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/uuid/lib/rng-browser.js","webpack:///./node_modules/uuid/v4.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/scripts/main.js","webpack:///./src/scripts/sample.js","webpack:///./src/scripts/vivagraph.js","webpack:///./src/scripts/webgl-utils.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACjCA,UAAU,mBAAO,CAAC,yDAAW;AAC7B,kBAAkB,mBAAO,CAAC,iEAAmB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5BA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;ACnBA,aAAa,mBAAO,CAAC,+CAAa;AAClC,mBAAmB,mBAAO,CAAC,mDAAe;AAC1C,eAAe,mBAAO,CAAC,0CAAS;AAChC,eAAe,mBAAO,CAAC,yCAAU;;AAEjC;AACA;AACA;AACA;AACA,kCAAkC,wBAAwB;AAC1D,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAA8C;AAC3E;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,WAAW,oBAAoB;AAC/B;AACA,uBAAuB,8CAA8C;AACrE;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;;AAGA;AACA;AACA;AACA,CAAC;AACD;;;AAGA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;;AAEA,WAAW,QAAQ;AACnB;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,mBAAmB,gBAAgB;AACnC,uCAAuC,+BAA+B;AACtE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,QAAQ;AACR,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,QAAQ;AACR,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,QAAQ;AACR,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,QAAQ;AACR,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,QAAQ;AACR,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;;AAEH;;;AAGA;AACA;AACA;;;AAGA;AACA;;;;;;;;;;;;AC7bA;;AAEA,gBAAgB,KAAK,IAA4D,sBAAsB,MAAM,EAAgO,EAAE;AAC/U;AACA;AACA,YAAY,8BAA8B,mBAAmB,aAAa,aAAa,oDAAoD,qBAAqB,OAAC,QAAQ,wBAAwB,4CAA4C,EAAE,IAAI,sCAAsC,EAAE,mBAAmB,YAAY,GAAG,iCAAiC,sBAAsB,kBAAkB,EAAE,4BAA4B,EAAE,qBAAqB,EAAE,kDAAkD,gBAAgB,cAAc,aAAa,UAAU,EAAE;AACtiB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;AACX,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,gCAAgC;AAC7C,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gCAAgC;AAC7C,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,UAAU;AACtC;;AAEA;AACA,4BAA4B,UAAU;AACtC;AACA,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB,gCAAgC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;;AAE3C;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA,4FAA4F,iBAAiB;AAC7G;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B,iBAAiB;AACjB,mBAAmB;AACnB;AACA;AACA,sBAAsB,uBAAuB;AAC7C,0BAA0B;AAC1B,qCAAqC;AACrC;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ,gDAAgD;AACzE;AACA;AACA;AACA,+CAA+C;;AAE/C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,iBAAiB,OAAO;AACxB,iBAAiB,YAAY,EAAE,KAAK;AACpC,iBAAiB,UAAU,EAAE,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ,0CAA0C;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,KAAK,GAAG,sDAAsD;AAC9D;AACA;AACA,KAAK,GAAG,SAAS;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sBAAsB,UAAU;AAChC,KAAK,GAAG,qBAAqB;AAC7B;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B,uBAAuB,WAAW;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B,uBAAuB,OAAO;AAC9B;AACA,0BAA0B,gCAAgC;AAC1D,0BAA0B,kCAAkC;AAC5D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B,uBAAuB,OAAO;AAC9B,yBAAyB,OAAO;AAChC;AACA;AACA,4BAA4B,wCAAwC;AACpE,4BAA4B,0CAA0C;AACtE,4BAA4B,8CAA8C;AAC1E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,eAAe;AACxC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;;AAEA;AACA;;AAEA;;AAEA,yBAAyB,iBAAiB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B,UAAU;AACrC;AACA;;AAEA,2BAA2B,UAAU;AACrC,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA;AACA,yBAAyB,mBAAmB;AAC5C,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,GAAG,0CAA0C;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C,wCAAwC;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,wBAAwB;AACxB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kFAAkF;AAClF;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,iBAAiB;AAC1C;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB,KAAK,gBAAgB;AACzD;AACA,KAAK,GAAG,qBAAqB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ,qCAAqC;AAC9D;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA,iBAAiB,+BAA+B;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,+BAA+B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,wBAAwB,QAAQ;;AAEhC;AACA,0BAA0B,QAAQ;;AAElC;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,wBAAwB,QAAQ,EAAE;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,sBAAsB;AAC9B;AACA;;AAEA;AACA;AACA;AACA,KAAK,GAAG,kCAAkC;AAC1C;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,GAAG,0CAA0C;AAClD;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,6BAA6B;AAC7B;;AAEA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,KAAK,GAAG,+DAA+D;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA,yBAAyB;AACzB,yBAAyB;AACzB;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C,0CAA0C;AAC1C;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,6EAA6E;AACrF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B,GAAG,WAAW,GAAG,uBAAuB;AACtF;AACA;AACA;AACA,KAAK,GAAG,kCAAkC;AAC1C;AACA;;AAEA,8BAA8B,OAAO;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;;AAEA,wCAAwC;;AAExC;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;;AAE3B;AACA,oCAAoC;;AAEpC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,yBAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,uBAAuB;AAC/B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA,uBAAuB,2CAA2C;AAClE;;AAEA;AACA;AACA,WAAW;;AAEX;AACA,oCAAoC,qBAAqB,EAAE,OAAO,uBAAuB;AACzF,WAAW;AACX;AACA,mCAAmC,oBAAoB;AACvD,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,WAAW,uBAAuB,EAAE;;AAE9D;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC,aAAa;AACb,oCAAoC;AACpC;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,gFAAgF;AAChF,eAAe;AACf,oFAAoF;AACpF;AACA,aAAa;AACb;AACA,mFAAmF;AACnF,eAAe;AACf,uFAAuF;AACvF;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gCAAgC,mDAAmD;AACnF;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,wBAAwB,WAAW,uBAAuB,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA,KAAK,GAAG,yGAAyG;AACjH;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kCAAkC,6CAA6C;AAC/E;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK,GAAG,qCAAqC;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,4CAA4C,2BAA2B;AACvE,4CAA4C,2BAA2B;AACvE,4CAA4C,2BAA2B;AACvE,4CAA4C,2BAA2B;AACvE,WAAW;;AAEX,sFAAsF;;AAEtF;AACA;AACA;AACA,WAAW;;AAEX;AACA,8CAA8C,QAAQ;;AAEtD;AACA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe;AACf;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB,WAAW;;AAEX;AACA,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA;AACA;AACA;AACA,KAAK,GAAG,kEAAkE;AAC1E;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,qBAAqB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,GAAG,wBAAwB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,gBAAgB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,oDAAoD;AACzE;AACA,mDAAmD,aAAa;AAChE;AACA,eAAe,aAAa,mCAAmC,aAAa;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO,sIAAsI;AAC7I,KAAK,IAAI;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,GAAG,wBAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,iCAAiC;AACjC,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX,uBAAuB,aAAa;AACpC,2BAA2B,aAAa;AACxC,yBAAyB,aAAa;;AAEtC;AACA;AACA,0CAA0C,YAAY,SAAS,YAAY,GAAG,QAAQ,GAAG,QAAQ;AACjG;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,IAAI,SAAS,IAAI,GAAG,IAAI,GAAG,IAAI;AACvE;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA,mEAAmE;;AAEnE;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,IAAI,SAAS,IAAI,GAAG,IAAI,GAAG,IAAI;AACvE;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,GAAG,uEAAuE;AAC/E;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;AACA;AACA,iCAAiC;AACjC,WAAW;;AAEX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD,gCAAgC,+CAA+C;AAC/E,gCAAgC,+CAA+C;AAC/E;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA,WAAW;;;AAGX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,yBAAyB;AACzB;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA,0CAA0C,QAAQ;;AAElD,2BAA2B;AAC3B,6BAA6B;AAC7B,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC;AACnC,qDAAqD;AACrD;AACA,mCAAmC;AACnC;AACA,WAAW,+BAA+B;AAC1C;AACA,WAAW;AACX,+FAA+F,MAAM;AACrG;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB,oCAAoC;AAC7D;AACA;AACA;AACA;AACA;AACA,4EAA4E,KAAK;AACjF;;AAEA;AACA,aAAa;AACb;AACA;AACA,0EAA0E,KAAK;AAC/E;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;;AAEA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,cAAc;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,wBAAwB;AACxB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,GAAG,qBAAqB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,IAAI;AAC5C;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,IAAI;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC,8BAA8B;AAC9B,sCAAsC;AACtC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;;AAExC,4BAA4B;AAC5B,0CAA0C;AAC1C,uEAAuE;AACvE,eAAe,kCAAkC;AACjD,uEAAuE;AACvE,eAAe,kCAAkC;AACjD,uEAAuE;AACvE,eAAe,kCAAkC;AACjD,uEAAuE;AACvE,eAAe,OAAO,iCAAiC,EAAE;AACzD,YAAY;AACZ;AACA;;AAEA;AACA;AACA,sCAAsC;;AAEtC,8CAA8C;AAC9C,qCAAqC;AACrC,oCAAoC;AACpC,2CAA2C;AAC3C,sCAAsC;;AAEtC,4BAA4B;AAC5B,+EAA+E;AAC/E,sDAAsD;AACtD,oFAAoF;AACpF,uDAAuD;AACvD,2CAA2C;AAC3C,0DAA0D;AAC1D,wDAAwD;;AAExD,8BAA8B;AAC9B,2CAA2C;AAC3C,YAAY,yBAAyB;AACrC,2CAA2C;AAC3C,YAAY,yBAAyB;AACrC,2CAA2C;AAC3C,YAAY,OAAO;AACnB,2CAA2C;AAC3C,YAAY;;AAEZ,qCAAqC;AACrC,oDAAoD;AACpD,iDAAiD;AACjD,qFAAqF;AACrF,YAAY;AACZ;AACA;AACA,KAAK,GAAG,0CAA0C;AAClD;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK,GAAG,mCAAmC;AAC3C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,wBAAwB;AAChC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,gCAAgC;AAChC,8BAA8B;AAC9B,qCAAqC;AACrC,cAAc;AACd;;AAEA;AACA,wCAAwC;AACxC,oCAAoC;;AAEpC,uCAAuC;AACvC,sCAAsC;;AAEtC,gCAAgC;;AAEhC,8BAA8B;AAC9B,qFAAqF;AACrF,qCAAqC;AACrC,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK,GAAG,mBAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,mCAAmC;AACnC,8BAA8B;;AAE9B,4BAA4B;AAC5B,mCAAmC;AACnC,YAAY;AACZ;AACA;AACA,sCAAsC;AACtC,kCAAkC;AAClC,qCAAqC;AACrC,oCAAoC;AACpC,8BAA8B;;AAE9B,4BAA4B;AAC5B,kFAAkF;AAClF,+DAA+D;AAC/D,mCAAmC;AACnC,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK,GAAG,mBAAmB;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,wBAAwB;AAChC;AACA;AACA;AACA,KAAK,IAAI;AACT,GAAG,IAAI;AACP,CAAC;;;;;;;;;;;;;ACtvOD,aAAa,mBAAO,CAAC,+CAAa;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,4BAA4B;AAC5B,0BAA0B;AAC1B,+HAA+H;AAC/H,mCAAmC;AACnC,aAAa,OAAO;AACpB,qCAAqC;AACrC,aAAa;AACb,UAAU;AACV;AACA,oCAAoC;AACpC;AACA;AACA;AACA,2CAA2C;AAC3C,mCAAmC;AACnC,kCAAkC;AAClC,4BAA4B;AAC5B,0BAA0B;AAC1B,6EAA6E;AAC7E,qEAAqE;AACrE,4CAA4C;AAC5C,oCAAoC,oBAAoB;AACxD,oCAAoC,oBAAoB;AACxD,oCAAoC,oBAAoB,gBAAgB;AACxE,0BAA0B;AAC1B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,GAAG;;AAEH","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/scripts/main.js\");\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","const Viva = require('./vivagraph');\nconst WebglUtils = require('./webgl-utils');\nconst uuidv4 = require('uuid/v4');\nconst Sample = require('./sample');\n\nconst SocketUtils = (function () {\n  const socket = new WebSocket('wss://ws.blockchain.info/inv');\n  const startSocket = (callback) => {\n    socket.addEventListener('open', () => {\n      socket.send(JSON.stringify({ op: 'unconfirmed_sub' }));\n    });\n    socket.onmessage = (event) => {\n      callback(event);\n    };\n\n    socket.onerror = (event) => {\n      console.log(event);\n    };\n  };\n  return {\n    startSocket,\n  };\n}());\n\n/* eslint-disable no-use-before-define */\nconst TransactionUtils = (function () {\n  const _addNodes = (nodes, hash, type) => {\n    const test = type === 'input' ? 'output' : 'input';\n    nodes.forEach((node) => {\n      let addr = null;\n      const addrLookup = {\n        input: () => (node.prev_out.addr ? node.prev_out.addr + type + uuidv4() + hash : null),\n        output: () => (node.addr ? node.addr + type + uuidv4() + hash : null),\n      };\n\n      const fn = addrLookup[type];\n      if (fn) addr = fn();\n      if (addr) {\n        const matchedNodes = App.findMatchingNodes(addr, hash, type, test);\n        if (!matchedNodes.length) {\n          App.addNode(addr, { type, hash, timestamp: new Date().getTime() });\n          App.addLink(hash, addr);\n        } else {\n          matchedNodes.forEach((matchedNode) => {\n            App.addLink(hash, matchedNode.id);\n            App.setType(matchedNode, 'mixed');\n          });\n        }\n      }\n    });\n    App.updateInfo('node-count', App.getNodeCount());\n  };\n\n  const _buildNodesAndLinks = (tx) => {\n    const { inputs, out, hash } = tx.x;\n    // Add node for transaction\n    App.addNode(hash, { type: 'tx', timestamp: new Date().getTime() });\n    _addNodes(inputs, hash, 'input');\n    _addNodes(out, hash, 'output');\n  };\n\n\n  const _isBoring = (nodeIds) => {\n    let txCount = 0;\n    // End early if 4 or more nodes\n    if (nodeIds.length > 4) {\n      return false;\n    }\n    for (let i = 0; i < nodeIds.length; i++) {\n      const id = nodeIds[i];\n      if (id.indexOf('input') === -1 && id.indexOf('output') === -1) {\n        txCount++;\n      }\n    }\n    if (txCount > 2) {\n      return false;\n    }\n    return true;\n  };\n\n\n  const handleMessage = (message) => {\n    const tx = JSON.parse(message.data);\n    if (tx.op === 'utx') {\n      _buildNodesAndLinks(tx);\n    }\n    while (App.getNodeCount() > App.getNodeLimit()) {\n      App.forEachNode((node) => {\n        const timeSinceCreated = new Date().getTime() - node.data.timestamp;\n        if (timeSinceCreated > App.getStaleNodeTime()) {\n          console.log(App.getNodeCount());\n          App.removeNode(node.id);\n        }\n      });\n    }\n  };\n\n\n  return {\n    handleMessage,\n  };\n}());\n  /* eslint-enable no-use-before-define */\n\n\nconst App = (function () {\n  const NODE_LIMIT = 10000;\n  const STALE_NODE_TIME = 60000 * 9; // 10 min\n  const SCALE_COEFFICIENT = 4;\n  const INITIAL_ZOOM = 0.04;\n  const FORCE_CONFIG = {\n    springLength: 80 * SCALE_COEFFICIENT,\n    springCoeff: 0.0002,\n    dragCoeff: 0.009,\n    gravity: -30 * SCALE_COEFFICIENT,\n    theta: 0.7,\n  };\n\n  const GRAPHICS_OPTIONS = {\n    clearColor: true,\n    clearColorValue: {\n      r: 0.0078,\n      g: 0,\n      b: 0.2471,\n      a: 1,\n    },\n  };\n\n  function _WebglCircle(size, color) {\n    this.size = size;\n    this.color = color;\n  }\n\n\n  const graph = Viva.Graph.graph();\n  const layout = Viva.Graph.Layout.forceDirected(graph, FORCE_CONFIG);\n  const graphics = Viva.Graph.View.webglGraphics(GRAPHICS_OPTIONS);\n  const circleNode = WebglUtils.buildCircleNodeShader();\n  graphics.setNodeProgram(circleNode);\n  graphics.node(node => new _WebglCircle(50 * SCALE_COEFFICIENT, App.getNodeColor(node)));\n  graphics.link(() => Viva.Graph.View.webglLine(WebglUtils.getLinkColor()));\n  const renderer = Viva.Graph.View.renderer(\n    graph,\n    {\n      layout,\n      graphics,\n      renderLinks: true,\n      container: document.getElementById('graph-container'),\n      prerender: true,\n    },\n  );\n\n\n  const _getLinkedNodeIds = (node, nodeIds) => {\n    if (!nodeIds.length) {\n      nodeIds.push(node.id);\n    }\n\n    const { links } = node;\n    let linkedId = '';\n    for (let i = 0; i < links.length; i++) {\n      const link = links[i];\n      if (node.data.type !== 'tx') {\n        linkedId = link.fromId;\n      } else {\n        linkedId = link.toId;\n      }\n      if (nodeIds.indexOf(linkedId) === -1) {\n        nodeIds.push(linkedId);\n        _getLinkedNodeIds(App.getNode(linkedId), nodeIds);\n      }\n    }\n    return nodeIds;\n  };\n\n  const _markNodesInteresting = (node) => {\n    const linkedNodeIds = _getLinkedNodeIds(node, []);\n    for (let i = 0; i < linkedNodeIds.length; i++) {\n      const interestingNode = App.getNode(linkedNodeIds[i]);\n      interestingNode.data.interesting = !interestingNode.data.interesting;\n    }\n  };\n\n  const events = Viva.Graph.webglInputEvents(graphics, graph);\n  events.dblClick((node) => {\n    _markNodesInteresting(node);\n    console.log(node);\n  });\n\n  const updateInfo = (target, value) => {\n    document.getElementById(target).innerHTML = value;\n  };\n\n  const startGraph = () => {\n    const startTime = Date.now();\n    setInterval(() => {\n      const elapsedTime = Date.now() - startTime;\n      updateInfo('elapsed-time', elapsedTime);\n    }, 100);\n    renderer.run();\n    while (renderer.getTransform().scale > INITIAL_ZOOM) {\n      renderer.zoomOut();\n    }\n    updateInfo('stale-node-time', STALE_NODE_TIME);\n    updateInfo('node-limit', NODE_LIMIT);\n    SocketUtils.startSocket(TransactionUtils.handleMessage);\n  };\n\n  const loadSamples = () => {\n    renderer.run();\n    while (renderer.getTransform().scale > INITIAL_ZOOM) {\n      renderer.zoomOut();\n    }\n    const { txs } = Sample;\n    for (let i = 0; i < txs.length; i++) {\n      TransactionUtils.handleMessage(({ data: JSON.stringify(txs[i]) }));\n    }\n  };\n\n  const addNode = (hash, data) => {\n    graph.addNode(hash, data);\n  };\n\n  const addLink = (source, target) => {\n    graph.addLink(source, target);\n  };\n\n  const getNodeColor = (node) => {\n    const colorMap = {\n      tx: () => WebglUtils.getTxNodeColor(),\n      input: () => WebglUtils.getInputNodeColor(),\n      output: () => WebglUtils.getOutputNodeColor(),\n      mixed: () => WebglUtils.getMixedNodeColor(),\n    };\n    if (node.data && colorMap[node.data.type]) {\n      return colorMap[node.data.type]();\n    } return WebglUtils.getUnknownNodeColor();\n  };\n\n  const setType = (node, type) => {\n    const updatedNode = node;\n    updatedNode.data.type = type;\n    const nodeUI = graphics.getNodeUI(node.id);\n    nodeUI.color = getNodeColor(updatedNode);\n    renderer.rerender();\n  };\n\n\n  const findMatchingNodes = (id, hash, type, test) => graph.getNodesWithId(id, hash, type, test);\n\n  const getNodeCount = () => graph.getNodeCount();\n\n  const getNodeLimit = () => NODE_LIMIT;\n\n  const getStaleNodeTime = () => STALE_NODE_TIME;\n\n  const getNode = nodeId => graph.getNode(nodeId);\n\n  const getAllNodes = () => graph.getAllNodes();\n\n  const removeNode = id => graph.removeNode(id);\n\n  const forEachNode = callback => graph.forEachNode(callback);\n\n  const removeLink = link => graph.removeLink(link);\n\n  return {\n    startGraph,\n    loadSamples,\n    addNode,\n    addLink,\n    getNodeColor,\n    setType,\n    findMatchingNodes,\n    getNodeCount,\n    getNodeLimit,\n    getStaleNodeTime,\n    getNode,\n    getAllNodes,\n    removeNode,\n    forEachNode,\n    removeLink,\n    updateInfo,\n  };\n}());\n\nApp.startGraph();\n","const txs = [\n  // {\n  //   op: 'utx',\n  //   x: {\n  //     lock_time: 549188,\n  //     ver: 1,\n  //     size: 5091,\n  //     inputs: [{\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387444493, type: 0, addr: '1HFen5X2yTvSRaL2BBui3fRX9KiTH1oVim', value: 400000, n: 0, script: '76a914b2475eee98b8f7915f60bf07d8952c0dd3e806b088ac',\n  //       },\n  //       script: '483045022100aca79edc2d3ff829882e6d246a14120bd518224363ddb75391b9c1ca630361060220361f0e62fea2c063d475ecf6ea7175764e2eaba27a374dfb4c2244c657e61e720121023d018223c183f0b38d122a6a45b20c9f77dd372bc88e1c12b2113abbcd9068fa',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387431487, type: 0, addr: '1AwF8ATDJmr3D6azUbVcVyqoTUEp3mKFyK', value: 543728, n: 0, script: '76a9146cfb6239c827b1c4bc7ad91bc4ac57f13d807e7c88ac',\n  //       },\n  //       script: '483045022100b16b199e1a44b6b5c28835df337b52c9fc320c175d065e7c6959eb6ba6698d0302201d6a6264fea4aba83d93d8d5547687fa534ffedc4b9b0aa77b782f313f6aea3d01210286f35ec1a9187e56593dd843d599f56929b24749ae040c21d969d7333c0de335',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387446347, type: 0, addr: '1PCg6PjM644hePxVofUCcLYBsxg5mjH2GC', value: 300000, n: 3, script: '76a914f387f9da305594c9afd962b765903b812153e96288ac',\n  //       },\n  //       script: '483045022100c8f7a91375eb2f0565f8d99e06a76d2d81fdcd1b458bf6ebe266c63c5423652302207f86574e2b982c44e6ab4de151c956060325b6d2e3dc38e7b46031da5c4f8746012102a3384e5c0244499ae258f37e29aee4635a6d88eb697f4e894f3b996e0f283cb0',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387416606, type: 0, addr: '1LcmSvQyZYcDmGmh7LJwyneNQhCccFioQB', value: 153233, n: 1, script: '76a914d72e0d0c442d20277a088cad83ad378c23d2b6b588ac',\n  //       },\n  //       script: '483045022100948295d2d401c8a4ebba189c030b2ce37b71b079b8f6a19cbbb2298491723844022072806bb111eb3e9140ea82bbd9995179ec59859d81e02693b006cd9d27ea5a8e0121035416c67f726b81f1e79af3dc788ea092289f5f56b3a9e9ab730f70d6447dcc1f',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387437993, type: 0, addr: '1NsgTPu6RRgfK2w7ASfM6xesYsXXEYSxvE', value: 74000, n: 2, script: '76a914eff05fff8dfc84bd3cf9ee1a1949aa258709515f88ac',\n  //       },\n  //       script: '47304402201201378283f7fa82bfb1d78a3735c4d8f9e5f5413ec56b557025a89b1f491a1e02206c9ea8cc5ff253834ff4afd75f1990eacd1cb895a0994ca27b42f7b37bacf93701210302e0af3d6c6f4e9ff53a21c041ec4d3ab6281d42654ba47403151144bfce364a',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387435811, type: 0, addr: '1AzQgy9oSnDhQ6QszDHRnY1fWcWBrzK8sk', value: 199588, n: 0, script: '76a9146d949dd5ef0b706e428b5db432682f0cd161d9ea88ac',\n  //       },\n  //       script: '4730440220676a4e1f432104bb8c9ee1dab259716fae9ef677f21517fc3ba9eebfc178805e02205cd134af5b924c720f71ebbad13b2bae2b9fd8accc452c43b75d6aa907713f02012102782511238544723f92c7e173ddd0030d349d374072f3f6393386cfa8eabc0a61',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387452464, type: 0, addr: '1N8ypKQR1RJvgj9vzRs5iguhcwBCxKBCZY', value: 197000, n: 3, script: '76a914e7dcfb0ba2a203aa7caa50a6c300dc5896d17d1388ac',\n  //       },\n  //       script: '47304402206fff1a59ae9fcddbcf05410c69e48891b192d2dcdc7449c88e6a6912d4042641022059ef2b731c1b6f054958e8d5eb42a9547cdcadda7b45845dac5fa8d4f57d4a1301210356ec62a3a359fce3a511d8b9a1bf4a5c2f5ebb533e47f66eb7ed064da3ffeb77',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387444088, type: 0, addr: '1QE81HzKCP9EPoViir96Mmnsa3BgniSu2Q', value: 700000, n: 1, script: '76a914fec625e6b24b36fe0fe2216f7101247179cf673988ac',\n  //       },\n  //       script: '483045022100e0af2892a39d003ef0163506e2c8d1cf9ed8cd7a75e78a6bbdb3514964f5949802204fb63e08a50277d04ee0039bf0d71777b7760a103c1ded7207d20cc85f15bda3012102f0803544699000990bb691551cbcb66b7502dc853308097a28593b61b2939741',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387449699, type: 0, addr: '1ARbqWFmGjDFt6c1ySBJNidwu1pPrAUDdL', value: 85000, n: 0, script: '76a914676031eb98c9f209fb21d6d9bc85b398004b750788ac',\n  //       },\n  //       script: '4730440220520fb8e866d784bf23f488f960d7bff0228edbe5540e07cfcf46c7960c905ddd022001ca8247d8f3e4933a857271a728e53a5df00f6d88f029fc44e5b3f698a53719012102728591a78f6798690291257516671cf5b8203e1ad72117b15ba740078802c0a5',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387473633, type: 0, addr: '17gj54ELwDJF71rj6hr5MAD6niVuuetjiR', value: 85912, n: 0, script: '76a9144954186d4e70a33bc13bf2d52c85ebf89f0f951d88ac',\n  //       },\n  //       script: '47304402201afdebab02ee1a430bf3c4bba450743e09121346f4c770a88052a658fa396b8e02207b6d3cd61f7ae9e601baf72611101614feb11a976a193351aa72e30ab9f68db901210242e138228ea6b26302a1e59b47b27b6e53647a3b1ab3d6a34c3f9351ce1688a5',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387474612, type: 0, addr: '154bBzxJPEJbY49y5iRtFS5epn91cN6feS', value: 60000, n: 8, script: '76a9142c8e4a85410664fb0a094ae4c02f64486f274d3088ac',\n  //       },\n  //       script: '47304402206241d7a90d0961f4427e94db518f3cef0f526964c2efb53935c1c7ce3220ae7a022010a2798010bd0405c44ac5a4562e94795624c31259036afb5082eb5cf0028ff80121028af76221a6300066933bf62488f569ad304841e398082e9d97f3c3bb850dee2b',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387413953, type: 0, addr: '1FnrzrFrCSuFnUAMvCD54w6kD2wgTRdw8k', value: 64000, n: 83, script: '76a914a23e37090ad1027411ec8579d713dbfa68ca7a1b88ac',\n  //       },\n  //       script: '483045022100f41b4bf6a10340de270535dc2a9a78400e52fdf3a311034d3e392d0c1b58e4010220383702199d74d5e277cd800db5b771b21ef846361e1cbb669477c6eee4cfe4d401210335c76526c5c737fc2bf7f542318d6df1462e4b2010c8726e95ea713d38481612',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387390789, type: 0, addr: '16fAQCemDqeBadYiTx4BqR8ro2iQeVhDLZ', value: 182867, n: 0, script: '76a9143e10483e8c1d464b122a37fe579e4d332735140b88ac',\n  //       },\n  //       script: '483045022100804fe9f8b0260079c436aece0f78f3c3841eb5059d97890d83e944d81f8f75bf02201e18a4cfb180124e429a6d87425d2412aa642fd20b1bc7568e64bbb8e811b86301210300d26422cd89bc2412e95b61ef6eb20abd3b9f5c5723bf46d3e9692a2dbb464a',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387501284, type: 0, addr: '1L2L2WPJTqucr9rr4ZGZfQeaw8nzHkPcAU', value: 139840, n: 0, script: '76a914d0aab01cc22c46d4364697cf58c8918e3051bed488ac',\n  //       },\n  //       script: '483045022100b231b55abb673328745a0236b9e7c52f9f88c5cf1485065a0ec240bbe085f6b602207fa25435cb08544987afee9853d30aec0a91fc08ac5aaf37f6f4d4715b6929ef012103eab7f0be543eddfdc1483adedd71712a93d641ccc74289f916f1346ded8b84ac',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387463026, type: 0, addr: '17RKiSGef5p4wB59npEo2QLTwYaLZPoLRo', value: 205300, n: 2, script: '76a914466a5c1b00676247b13a97134aa5a5abe4c9e99088ac',\n  //       },\n  //       script: '47304402206893a9f01ae13ebbf45a70233f98f697340706b3d15375c4a21a0676a3d46e8c02202c8fb6b8c532312da7a1530ba4d306caf5ee15d86a619facfe66905f6ecaaf26012103d12d4313356719f8830983414dbc0d05ef0475ebdcad787249fcef6bf40527c5',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387482658, type: 0, addr: '19wCScrkjjgN43ptVze4xuxH1oxWc3GQLD', value: 434801, n: 0, script: '76a914620104edafc6fa0866142e5b7187deb2da6d14af88ac',\n  //       },\n  //       script: '47304402201d5a33b034c9a4155523f19d6265d1ef83c47d99ef6a710e146fe8283bf09e8a022055d2adb2bafe45a00d151008ae7864bb049e68bbb67f23e63cfc4ad15e08d6d60121036c534fbfb523099e252552838f96e66336e4869d297a4a24a27dcca53e44650c',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387401998, type: 0, addr: '15FDPx7nd1cX5juaUHAhkk8nJiFko5cim8', value: 160000, n: 2, script: '76a9142e90ac8b97b3b6fab7128c355e84b1b2877959e688ac',\n  //       },\n  //       script: '47304402203b039f6fbb2eed5405ab5f2bb0764df6c2f1f9501a0bc01e9e29898b7566f160022007b2b88df4c2139899c0268221d47a977268fef082e373e1781188295b02925e0121032271d35d390842daaf1ef5343210d166b3a9735da9fa6fd1d95f642f10dcf068',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387442987, type: 0, addr: '1HSKcnq3fxgcvBsjXLfDusZLwk89ZBw7on', value: 300000, n: 4, script: '76a914b44bf3cc25da000310decdd655d5c6e8a4d7f17d88ac',\n  //       },\n  //       script: '483045022100ea47ac8ae765eac2d40bc43c0e0fdd9b9eb00d8873c1e2619edbe38c590b69eb02206e9d4e4bdcd59509c548da7827ae4029ce7e8751a83bbc40e3329837c3d6ee2301210303839f72fb364cdf49a0834bdeae82fdbdf8ed0d2d8360c2c126455b2b32e470',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387457701, type: 0, addr: '1Mw1cro3ywHvF9aDMyfVJQ7VRA45ZV3xFJ', value: 200000, n: 3, script: '76a914e5997e63392ebf950cfda77aa110b65543f5302e88ac',\n  //       },\n  //       script: '4730440220713946598ce1acd3c2f5541b98f1bae40563dbf07a519e4c8b2533d2076a574302207a4f44dc95e492de5538f948517adc895497afc253aea40b40994ac16a4bdee6012102aa0aceecf73823befc9c55c48e7f07bf165a8a171436e7f2f4e32e6a8ab96611',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387431880, type: 0, addr: '1MmkuphndeMSpJULZgLNgY6ZKvuqv8KZpp', value: 104500, n: 0, script: '76a914e3d9790b3b208651efa29cc4c6cc219e18e42c4288ac',\n  //       },\n  //       script: '4730440220789e0cd2d91b3aaea1d74c1c9e31102261f40712b69287ff4fd768aa0eb3791302202e8437088c41c79af94f0b25704d5e41a59946a13967144de91b6cb2323819bf0121039abac500be6afe3c8f2291b179edb81232723609d6fc8998a3dba6e777219dca',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387498354, type: 0, addr: '1Af1aU1wGnd5HDXugtasfEkUhZckNZzmpi', value: 143800, n: 0, script: '76a91469e96b95caada3ac036d2237aac9f6d845a226d588ac',\n  //       },\n  //       script: '47304402207d027fdb196fbac05ad2537bb4ddc7fbdd535f838dcf8a96c923c1d45f8a08e10220480454dc314c94f52543164c08036e8fa87d5ac66f39ae3498e6d7016a3a7775012103935eabff772dc15fbdc361dafcf5bccaa81aa2390cbba8ef4475eecc63f3267b',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387394044, type: 0, addr: '1MSo645ywB7ipL419PN2o7Kg3uqzZ5ha9w', value: 111813, n: 0, script: '76a914e04362e57c487f80e8ff053ca23e1a4482b70c5988ac',\n  //       },\n  //       script: '4730440220025cb66a2cb3fc3bdedc34e3b7f0d0af0b6a1f1e3b62860fbdcb0d3fe93431f7022050665ad5970c5e0f4eb8c84120f3b2e923f0be47758ddc0a97c34552fd28052001210384d61ca051f205bcb8a2089a97394692bdecd61639cae0677f6ffcd21fbb7529',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387417557, type: 0, addr: '1EnQ2wrfXFKZqCvtWP5gsQwPhbZa4wcQYd', value: 174345, n: 0, script: '76a914972f94b65916fcf61a5d33dc575fae3e66380b5588ac',\n  //       },\n  //       script: '4730440220775f74d72e564b8bdb0d979e75ea2839a32a2369cda94f819713b3d7f0f08e3f022037ad8156fc03ad36ce01b9b634fc7de8261f82b3939b92fa1a73a1264419f97301210369ac344178bc0f42e8f041e109ff0f1d7ceded01c36b7c87df175c72e0b36f2e',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387400225, type: 0, addr: '1Jk7H8UWkg9r7uy5kqjqbzFaYZVggaYRVP', value: 152892, n: 1, script: '76a914c2a143eebeb7235556f4981370f5deddc1fd915b88ac',\n  //       },\n  //       script: '473044022014906599dd9a777813f861c03ab546db9f48f2f2836f242ef1053511621b47a202207d7cf74291e9a44185441131517e951524703547317cc5e3820bcc9bdfd1c7f00121028160f6579bcdb53ab413724feed5a72b4d3d34daf4cc0edbe5d0e3de99f9db87',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387381792, type: 0, addr: '112m3i52YHx4JL2PaifVgnTn3QB7fFJZZH', value: 720000, n: 5, script: '76a91400552f2d7fe7de80264dbff7be61bde2ffc635d688ac',\n  //       },\n  //       script: '4730440220209037a7ab09edba260e37b53e83d646c0d41815c725a0cd44ab00e087239b9702202d46e6d08d8d32a44ce84bcebbea84f8e10d404bda830e836d4eb365e58797380121034112aef6448bf6b9af2e829cfae4e13bad22e82ede0e8f956c4e4665c71022ea',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387415854, type: 0, addr: '1PrBisyebvbsbm7vYVrRGLELT1mT8AF9fr', value: 317000, n: 2, script: '76a914faa019851ee2b9909d965a76ca58b14f93917f6188ac',\n  //       },\n  //       script: '483045022100a14601630a5bceac6835418c716f85209ac965b96912100c1495f3bbaf2cd4cc022052f131cc3092414cadef3916ad55279057be6cb4a0d60aacc471934f1d2b61d501210226a480056bf5f8bd56ba803c9136eab125f24c87c0df6a7d4149ee4c555c9398',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387433641, type: 0, addr: '17U7N1JfZ46fad8KMQkzuTKmJLZpjaBHU6', value: 918398, n: 0, script: '76a91446f14be9ab94854c953a65ec32732f47e7a3b28288ac',\n  //       },\n  //       script: '483045022100bd1338e99c22794a15a29f67b9eadb295c438f95454e91efaedab6f82198e3090220545ed2f7913bdaf658b452226ad6c776cbe7bb4e5a6c62f91d96a50469a7fad101210269440a1b005c0053c10f557c53690ebb794ce3d717bb578b1062406b737b290f',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387452308, type: 0, addr: '12HwXcvJ9xmff829dc4CRmGwnrBwVgGDUM', value: 490000, n: 0, script: '76a9140e2c4c7d4a5ebb7d63b4761c1cdaeb1c86c4e9e888ac',\n  //       },\n  //       script: '483045022100fca391a1e9a477f3a0ace7726ec482ca8f12b70bf599ab9aa64d60f25df3cb2f02200a7927159e87128058193011ec7477a4490358e8fd5abed4ae553226bcad6a71012103a0acd94e542ee6246782c66fc2b56274c7cd527be1396602d41e3bc54c9221c7',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387420309, type: 0, addr: '1BjTy5CtAsnrTAdmTHXm1NRbYGK9YqhWHc', value: 166732, n: 5, script: '76a91475b93d2c41b5c0ae3cdfacf139605401fbcc5f6788ac',\n  //       },\n  //       script: '473044022011bdd6742bb66c090eeda600b0549b44c3b1c732e1dae6e3c33bdbf87b26a52e0220377bf596cdef83b5ee86305905a8cc959f9d4eca7c6b3579284fed0bf5b42ae1012102aed18e46d53153e3b58572bb0cee08dc77678117ded7bd6be355de9949ac3569',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387443377, type: 0, addr: '1AKm57AfztVqz8oPVA6AWh1ccKiUg4CypT', value: 64190, n: 0, script: '76a91466456866a602ed8e840890d3ac09a2af5f9e53b288ac',\n  //       },\n  //       script: '473044022028efe7aa4393b7d186572a4768e15c053deb0d7204b939dd00fa657c9fd14e2d02202ae1389be9049f544265b2a9b1d4c8584639af6e94c4c1d91221d02d1f8510950121037d39b7ce57bcb9acb2cc975c3172771822d6d535114c5980b1058f631a90243f',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387410648, type: 0, addr: '14tvUkWYs2m8aWxPegbo7i5PQRcN88gmTC', value: 88660, n: 4, script: '76a9142aba3ba39f3a9a7f84ed738586a8c2c2b4255c0788ac',\n  //       },\n  //       script: '47304402205131f2c1f153a3fba059839741744d87989853ec6f2f0451ea937bdc40eedebc02202a395ba6b55ff7fc79c0768ce373cb6d2e555827224cc312cebb208c6d13f0dd012103f64c5caf6dc31613eea1859323ebc55aa66f8815389bdd036f557123ead65064',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387395470, type: 0, addr: '1JHff5x7XLQpztaFVESLCuxRmyXzCDxcfx', value: 906065, n: 0, script: '76a914bda1100a1a51c3dda883dc288b34196e4a7b413b88ac',\n  //       },\n  //       script: '483045022100a4aa373e1e608ec9360d3572c1b4e3d52f102c468c39c341222a1ead35bff3ea022038b3ecf224456196b83f62a6c9dcf78c8943a2d491c664e4878edd013b1301ec01210359ff9c0f82ae2f246a37ecbccdb655eb3e9dafab1412d6e7e753cce521acd2c6',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387480814, type: 0, addr: '12dYYxfbPuzXunEyg2y9SEhUpBsBVk9hDn', value: 82000, n: 0, script: '76a91411e1701905abf32f29e4e7af322da5740f95fd6f88ac',\n  //       },\n  //       script: '483045022100cabfb8f14e1fa7f57580acca4bf02d1557936799fc7e0572b4ce91eb23adc85f02200ab3ad2c153c5a2c4aac658522dc16a962360390177a4783895cc9f9c12475460121039ae861556674f6ea4a1e097b09d1e92a27defd70e6534dff8c8a7e574f713929',\n  //     }, {\n  //       sequence: 4294967293,\n  //       prev_out: {\n  //         spent: true, tx_index: 387409495, type: 0, addr: '1Gy2ST3PE5eWeroSaRkjSEMCKeqkabDdi3', value: 1148600, n: 0, script: '76a914af2261b391774a2589a624bb9982bd516bb7272c88ac',\n  //       },\n  //       script: '483045022100c06a4e75025a42e7215442e1259d7ee73c599b9701546095df36759225aefc7002203ff683e04e070ba4fb496618aad8e70caca3db97dc395c972b828355fb46c9e10121037b50186b80c9f918e1f9219922d93415a0251b40fd492bc6f25245725890c489',\n  //     }],\n  //     time: 1541629879,\n  //     tx_index: 387517027,\n  //     vin_sz: 34,\n  //     hash: 'f09ac1f35afbe4d4688add4cb548190e6bb7cc04b6d617b0092cadf464f03231',\n  //     vout_sz: 2,\n  //     relayed_by: '0.0.0.0',\n  //     out: [{\n  //       spent: false, tx_index: 387517027, type: 0, addr: '1LJ7pMdHUnzf2qgpn4saC31JUuhi3dVvFq', value: 17543, n: 0, script: '76a914d3a726beddb9d1d2e519a91727c409e152687cb688ac',\n  //     }, {\n  //       spent: false, tx_index: 387517027, type: 0, addr: '1J4NuwvHJXyYiAiJFKvHJeyTLLZLrHUXhe', value: 10000000, n: 1, script: '76a914bb1dad9bc727d5a85364d3bb732147e049ccb16a88ac',\n  //     }],\n  //   },\n  // },\n\n  // {\n  //   op: 'utx',\n  //   x: {\n  //     lock_time: 0,\n  //     ver: 2,\n  //     size: 225,\n  //     inputs: [{\n  //       sequence: 4294967295,\n  //       prev_out: {\n  //         spent: true, tx_index: 387506419, type: 0, addr: '1J4NuwvHJXyYiAiJFKvHJeyTLLZLrHUXhe', value: 4341192, n: 1, script: '76a914bb1dad9bc727d5a85364d3bb732147e049ccb16a88ac',\n  //       },\n  //       script: '473044022050dc6085662978c092b80d591d66332d1093cd2618f73ed596f12c7d6957471102207b410a97446d788f0c5827e0017e75f0a10933913f471a533227f7d78fc2d372012103dc8300951da181c42db9d3ecc73e114f1eeff64feca5cabd07a3e215ee99c310',\n  //     }],\n  //     time: 1541629878,\n  //     tx_index: 387517021,\n  //     vin_sz: 1,\n  //     hash: '60b936229bb3d335e7d024106e809819f1d8a6b81d0fd4f7f64e716865db3d66',\n  //     vout_sz: 2,\n  //     relayed_by: '0.0.0.0',\n  //     out: [{\n  //       spent: false, tx_index: 387517021, type: 0, addr: '19wXx2LJpCzvtdnG94VVcJRrjRpwVmQqZg', value: 256500, n: 0, script: '76a91462114d880ddae28c9acfe7f1f877bd45bedca7b988ac',\n  //     }, {\n  //       spent: false, tx_index: 387517021, type: 0, addr: '1J4NuwvHJXyYiAiJFKvHJeyTLLZLrHUXhe', value: 4082358, n: 1, script: '76a914bb1dad9bc727d5a85364d3bb732147e049ccb16a88ac',\n  //     }],\n  //   },\n  // },\n\n  // {\n  //   op: 'utx',\n  //   x: {\n  //     lock_time: 0,\n  //     ver: 1,\n  //     size: 226,\n  //     inputs: [{\n  //       sequence: 4294967295,\n  //       prev_out: {\n  //         spent: true, tx_index: 387510271, type: 0, addr: '1HbqTMYn9sfy6qLSF7rDfgAz1PXy1TNNv3', value: 313505, n: 1, script: '76a914b6189a593c8cd400a97ebe2c80013d0fb12b486988ac',\n  //       },\n  //       script: '483045022100f54e34c6323e22a394549938ba0cca8e7761d9bba63617f9f612be312201c6dc02200c82e1defad556903f3667e141931a49f9e5ed92f11efb77e3af1a26b909b832012102dd85fb3d12e513a9dd5e0e97b49423a883f7fed7b64447140e31fba3d147bd4e',\n  //     }],\n  //     time: 1541629884,\n  //     tx_index: 387517037,\n  //     vin_sz: 1,\n  //     hash: 'd31c43b4cbd56f5e23ed0c8a649b9b0d3e26b95b303a708738138c2df4737ee9',\n  //     vout_sz: 2,\n  //     relayed_by: '127.0.0.1',\n  //     out: [{\n  //       spent: false, tx_index: 387517037, type: 0, addr: '12GcuyLgzQXYataWHEqoaAvRvrVXEbb4Zg', value: 5575, n: 0, script: '76a9140dec581876f2db689f2984753258ebf37d3f1a6b88ac',\n  //     }, {\n  //       spent: false, tx_index: 387517037, type: 0, addr: '1HbqTMYn9sfy6qLSF7rDfgAz1PXy1TNNv3', value: 306800, n: 1, script: '76a914b6189a593c8cd400a97ebe2c80013d0fb12b486988ac',\n  //     }],\n  //   },\n  // },\n\n  // {\n  //   op: 'utx',\n  //   x: {\n  //     lock_time: 0,\n  //     ver: 1,\n  //     size: 225,\n  //     inputs: [{\n  //       sequence: 4294967295,\n  //       prev_out: {\n  //         spent: true, tx_index: 387510267, type: 0, addr: '1HbqTMYn9sfy6qLSF7rDfgAz1PXy1TNNv3', value: 319769, n: 1, script: '76a914b6189a593c8cd400a97ebe2c80013d0fb12b486988ac',\n  //       },\n  //       script: '47304402203a370defa0b1b5610ee5db402ea4b70a338204513fe3c6629e6a7158c8e53e4c0220055bd28e611af983b1fb21d72e958800922c02b907523d0c57c5e3108cfaf268012102dd85fb3d12e513a9dd5e0e97b49423a883f7fed7b64447140e31fba3d147bd4e',\n  //     }],\n  //     time: 1541629880,\n  //     tx_index: 387517028,\n  //     vin_sz: 1,\n  //     hash: 'fcdcee537b78b8449a2470908d5651d4e6496f538f1d442f3499e4a59edb19d9',\n  //     vout_sz: 2,\n  //     relayed_by: '127.0.0.1',\n  //     out: [{\n  //       spent: false, tx_index: 387517028, type: 0, addr: '1Gkost12NZPubF3LXGKRrBy3GT7tN7UVS2', value: 5575, n: 0, script: '76a914acd2e77d34e2783f5580a3561aee3be4de2ac79388ac',\n  //     }, {\n  //       spent: false, tx_index: 387517028, type: 0, addr: '1HbqTMYn9sfy6qLSF7rDfgAz1PXy1TNNv3', value: 312838, n: 1, script: '76a914b6189a593c8cd400a97ebe2c80013d0fb12b486988ac',\n  //     }],\n  //   },\n  // },\n\n  // {\n  //   op: 'utx',\n  //   x: {\n  //     lock_time: 0,\n  //     ver: 1,\n  //     size: 225,\n  //     inputs: [{\n  //       sequence: 4294967295,\n  //       prev_out: {\n  //         spent: true, tx_index: 387510267, type: 0, addr: 'a1HbqTMYn9sfy6qLSF7rDfgAz1PXy1TNNv3', value: 319769, n: 1, script: '76a914b6189a593c8cd400a97ebe2c80013d0fb12b486988ac',\n  //       },\n  //       script: '47304402203a370defa0b1b5610ee5db402ea4b70a338204513fe3c6629e6a7158c8e53e4c0220055bd28e611af983b1fb21d72e958800922c02b907523d0c57c5e3108cfaf268012102dd85fb3d12e513a9dd5e0e97b49423a883f7fed7b64447140e31fba3d147bd4e',\n  //     }],\n  //     time: 1541629880,\n  //     tx_index: 387517028,\n  //     vin_sz: 1,\n  //     hash: 'fcdcee537b78b8449a2470908d5651d4ae6496f538f1d442f3499e4a59edb19d9',\n  //     vout_sz: 2,\n  //     relayed_by: '127.0.0.1',\n  //     out: [{\n  //       spent: false, tx_index: 387517028, type: 0, addr: 'a1Gkost12NZPubF3LXGKRrBy3GT7tN7UVS2', value: 5575, n: 0, script: '76a914acd2e77d34e2783f5580a3561aee3be4de2ac79388ac',\n  //     }, {\n  //       spent: false, tx_index: 387517028, type: 0, addr: 'a1HbqTMYn9sfy6qLSF7rDfgAz1PXy1TNNv3', value: 312838, n: 1, script: '76a914b6189a593c8cd400a97ebe2c80013d0fb12b486988ac',\n  //     }],\n  //   },\n  // },\n\n  {\n    op: 'utx',\n    x: {\n      lock_time: 0,\n      ver: 1,\n      size: 225,\n      inputs: [\n        {\n          sequence: 4294967295,\n          witness: '0400483045022100a96731afb0dae7853138afcacf224ddbde582f219c53aec642a3ee6785a39c36022034d6c4189b82dfdd07272e6fff9874440ef222a225d074f7ee539980d016ba0a01483045022100f1eedae17cef5382782cfd7aa4179ddf0e03f1b6a2de4e460b3516e69d5a70f502206c0f065cf391d4ae4ff680c7c2bb50a0cd844da1c06ab760195d1d1e03ec7e6201475221028ad97ae65c66869e3c251c3023d8d2421be20855cfbcfcb9a9b03e02caf7425b2102719e7bd7bf2182c319d2c95133824867d903b302075a36202ebc12f2aae0dfc552ae',\n          prev_out: {\n            spent: true,\n            tx_index: 388844896,\n            type: 0,\n            addr: '33D5H3ucGvUMPphFgCjtDPwfUEiPTG6Vby',\n            value: 123836,\n            n: 1,\n            script: 'a91410a7677060c1bcf12736c4a07d94f63da16587f987',\n          },\n          script: '220020322d5d40d55099ff7f0e9a93b7c16a7e9ec8faa41df2025de30c9b06418b5bd2',\n        },\n      ],\n      time: 1541629880,\n      tx_index: 387517028,\n      vin_sz: 1,\n      hash: '7f026d781541750048c019ca5604a50325a8aad1dee1ae320ee26283449ab875',\n      vout_sz: 2,\n      relayed_by: '127.0.0.1',\n      out: [\n        {\n          spent: false,\n          tx_index: 388911606,\n          type: 0,\n          addr: '3M1pdiKRavXbEnVoBmK864PR3kTssZeaRK',\n          value: 73580,\n          n: 0,\n          script: 'a914d3f8de5c547646c48500f929dfe2d39020534cde87',\n        },\n        {\n          spent: false,\n          tx_index: 388911606,\n          type: 0,\n          addr: '33D5H3ucGvUMPphFgCjtDPwfUEiPTG6Vby',\n          value: 49844,\n          n: 1,\n          script: 'a91410a7677060c1bcf12736c4a07d94f63da16587f987',\n        },\n      ],\n    },\n  },\n\n  {\n    op: 'utx',\n    x: {\n      lock_time: 0,\n      ver: 1,\n      size: 225,\n      inputs: [\n        {\n          sequence: 4294967295,\n          witness: '0400483045022100a4bdff18f59c22112382e41736ea1cf54fdb5f0cfa54840ee8ff035210b820c8022043ea8275f4489526f22c437cd5769ef5021f221895efd8fb1f88bf6a2195ec96014730440220415675e4ed0ef077baefe9639fc55f2de2be14587a776efdd8f24168fc8d57b502207b12eea45e01bcaa9bc05b34f9d2b203ffc06650be2a8d7f58aa4517c8dd171301475221028ad97ae65c66869e3c251c3023d8d2421be20855cfbcfcb9a9b03e02caf7425b2102719e7bd7bf2182c319d2c95133824867d903b302075a36202ebc12f2aae0dfc552ae',\n          prev_out: {\n            spent: true,\n            tx_index: 388844912,\n            type: 0,\n            addr: '33D5H3ucGvUMPphFgCjtDPwfUEiPTG6Vby',\n            value: 179588,\n            n: 0,\n            script: 'a91410a7677060c1bcf12736c4a07d94f63da16587f987',\n          },\n          script: '220020322d5d40d55099ff7f0e9a93b7c16a7e9ec8faa41df2025de30c9b06418b5bd2',\n        },\n      ],\n      time: 1541629880,\n      tx_index: 387517028,\n      vin_sz: 1,\n      hash: '53882eb886c7cbc1a338be633978c8275059a266bdd005f150e4db6b46bceca6',\n      vout_sz: 2,\n      relayed_by: '127.0.0.1',\n      out: [\n        {\n          spent: false,\n          tx_index: 388911621,\n          type: 0,\n          addr: '37yzZQ4xh7MZjdxm9BTHnq3izxy5u32G5o',\n          value: 21000,\n          n: 0,\n          script: 'a9144506afdcf4dcf8159d95f175723008bff9d8513c87',\n        },\n        {\n          spent: false,\n          tx_index: 388911621,\n          type: 0,\n          addr: '33D5H3ucGvUMPphFgCjtDPwfUEiPTG6Vby',\n          value: 158176,\n          n: 1,\n          script: 'a91410a7677060c1bcf12736c4a07d94f63da16587f987',\n        },\n      ],\n    },\n  },\n\n];\n\n\nmodule.exports = {\n  txs,\n};\n\n\n// 7f026d781541750048c019ca5604a50325a8aad1dee1ae320ee26283449ab875\n// 53882eb886c7cbc1a338be633978c8275059a266bdd005f150e4db6b46bceca6\n","// /* eslint-disable */\n\n!(function (e) { if (typeof exports === 'object' && typeof module !== 'undefined')module.exports = e(); else if (typeof define === 'function' && define.amd)define([], e); else { let f; typeof window !== 'undefined' ? f = window : typeof global !== 'undefined' ? f = global : typeof self !== 'undefined' && (f = self), f.Viva = e(); } }(() => {\n  let define,\n    module,\n    exports; return (function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { const a = typeof require === 'function' && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); const f = new Error(`Cannot find module '${o}'`); throw f.code = 'MODULE_NOT_FOUND', f; } const l = n[o] = { exports: {} }; t[o][0].call(l.exports, (e) => { const n = t[o][1][e]; return s(n || e); }, l, l.exports, e, t, n, r); } return n[o].exports; } var i = typeof require === 'function' && require; for (let o = 0; o < r.length; o++)s(r[o]); return s; }({\n    1: [function (require, module, exports) {\n    /**\n * This is an entry point for global namespace. If you want to use separate\n * modules individually - you are more than welcome to do so.\n */\nconst fuckNode =null;\n\n      const random = require('ngraph.random');\n\n      const Viva = {\n        lazyExtend() {\n          return require('ngraph.merge').apply(this, arguments);\n        },\n        randomIterator() {\n          return random.randomIterator(...arguments);\n        },\n        random() {\n          return random.random(...arguments);\n        },\n        events: require('ngraph.events'),\n      };\n\n      Viva.Graph = {\n        version: require('./version.js'),\n        graph: require('ngraph.graph'),\n\n        serializer() {\n          return {\n            loadFromJSON: require('ngraph.fromjson'),\n            storeToJSON: require('ngraph.tojson'),\n          };\n        },\n\n        centrality: require('./Algorithms/centrality.js'),\n        operations: require('./Algorithms/operations.js'),\n\n        geom() {\n          return {\n            intersect: require('gintersect'),\n            intersectRect: require('./Utils/intersectRect.js'),\n          };\n        },\n\n        webgl: require('./WebGL/webgl.js'),\n        webglInputEvents: require('./WebGL/webglInputEvents.js'),\n\n        generator() {\n          return require('ngraph.generators');\n        },\n\n        Input: {\n          domInputManager: require('./Input/domInputManager.js'),\n          webglInputManager: require('./Input/webglInputManager.js'),\n        },\n\n        Utils: {\n        // TODO: move to Input\n          dragndrop: require('./Input/dragndrop.js'),\n          findElementPosition: require('./Utils/findElementPosition.js'),\n          timer: require('./Utils/timer.js'),\n          getDimension: require('./Utils/getDimensions.js'),\n          events: require('./Utils/backwardCompatibleEvents.js'),\n        },\n\n        Layout: {\n          forceDirected: require('ngraph.forcelayout'),\n          constant: require('./Layout/constant.js'),\n        },\n\n        View: {\n        // TODO: Move `webglXXX` out to webgl namespace\n          Texture: require('./WebGL/texture.js'),\n          // TODO: This should not be even exported\n          webglAtlas: require('./WebGL/webglAtlas.js'),\n          webglImageNodeProgram: require('./WebGL/webglImageNodeProgram.js'),\n          webglLinkProgram: require('./WebGL/webglLinkProgram.js'),\n          webglNodeProgram: require('./WebGL/webglNodeProgram.js'),\n          webglLine: require('./WebGL/webglLine.js'),\n          webglSquare: require('./WebGL/webglSquare.js'),\n          webglImage: require('./WebGL/webglImage.js'),\n          webglGraphics: require('./View/webglGraphics.js'),\n          // TODO: Deprecate this:\n          _webglUtil: {\n            parseColor: require('./WebGL/parseColor.js'),\n          },\n\n          // TODO: move to svg namespace\n          svgGraphics: require('./View/svgGraphics.js'),\n\n          renderer: require('./View/renderer.js'),\n\n          // deprecated\n          cssGraphics() {\n            throw new Error('cssGraphics is deprecated. Please use older version of vivagraph (< 0.7) if you need it');\n          },\n\n          svgNodeFactory() {\n            throw new Error('svgNodeFactory is deprecated. Please use older version of vivagraph (< 0.7) if you need it');\n          },\n\n          community() {\n            throw new Error('community is deprecated. Please use vivagraph < 0.7 if you need it, or `https://github.com/anvaka/ngraph.slpa` module');\n          },\n        },\n\n        Rect: require('./Utils/rect.js'),\n\n        svg: require('simplesvg'),\n\n        // TODO: should be camelCase\n        BrowserInfo: require('./Utils/browserInfo.js'),\n      };\n\n      module.exports = Viva;\n    }, {\n      './Algorithms/centrality.js': 36, './Algorithms/operations.js': 37, './Input/domInputManager.js': 38, './Input/dragndrop.js': 39, './Input/webglInputManager.js': 40, './Layout/constant.js': 41, './Utils/backwardCompatibleEvents.js': 42, './Utils/browserInfo.js': 43, './Utils/findElementPosition.js': 45, './Utils/getDimensions.js': 46, './Utils/intersectRect.js': 47, './Utils/rect.js': 49, './Utils/timer.js': 50, './View/renderer.js': 52, './View/svgGraphics.js': 53, './View/webglGraphics.js': 54, './WebGL/parseColor.js': 55, './WebGL/texture.js': 56, './WebGL/webgl.js': 57, './WebGL/webglAtlas.js': 58, './WebGL/webglImage.js': 59, './WebGL/webglImageNodeProgram.js': 60, './WebGL/webglInputEvents.js': 61, './WebGL/webglLine.js': 62, './WebGL/webglLinkProgram.js': 63, './WebGL/webglNodeProgram.js': 64, './WebGL/webglSquare.js': 65, './version.js': 66, gintersect: 3, 'ngraph.events': 9, 'ngraph.forcelayout': 11, 'ngraph.fromjson': 13, 'ngraph.generators': 14, 'ngraph.graph': 16, 'ngraph.merge': 17, 'ngraph.random': 30, 'ngraph.tojson': 31, simplesvg: 32,\n    }],\n    2: [function (require, module, exports) {\n      addEventListener.removeEventListener = removeEventListener;\n      addEventListener.addEventListener = addEventListener;\n\n      module.exports = addEventListener;\n\n      let Events = null;\n\n      function addEventListener(el, eventName, listener, useCapture) {\n        Events = Events || (\n          document.addEventListener ?\n            { add: stdAttach, rm: stdDetach } :\n            { add: oldIEAttach, rm: oldIEDetach }\n        );\n\n        return Events.add(el, eventName, listener, useCapture);\n      }\n\n      function removeEventListener(el, eventName, listener, useCapture) {\n        Events = Events || (\n          document.addEventListener ?\n            { add: stdAttach, rm: stdDetach } :\n            { add: oldIEAttach, rm: oldIEDetach }\n        );\n\n        return Events.rm(el, eventName, listener, useCapture);\n      }\n\n      function stdAttach(el, eventName, listener, useCapture) {\n        el.addEventListener(eventName, listener, useCapture);\n      }\n\n      function stdDetach(el, eventName, listener, useCapture) {\n        el.removeEventListener(eventName, listener, useCapture);\n      }\n\n      function oldIEAttach(el, eventName, listener, useCapture) {\n        if (useCapture) {\n          throw new Error('cannot useCapture in oldIE');\n        }\n\n        el.attachEvent(`on${eventName}`, listener);\n      }\n\n      function oldIEDetach(el, eventName, listener, useCapture) {\n        el.detachEvent(`on${eventName}`, listener);\n      }\n    }, {}],\n    3: [function (require, module, exports) {\n      module.exports = intersect;\n\n      /**\n * Original authors: Mukesh Prasad, Appeared in Graphics Gem II book\n * http://www.opensource.apple.com/source/graphviz/graphviz-498/graphviz/dynagraph/common/xlines.c\n * and adopted to javascript version by Andrei Kashcha.\n *\n * This function computes whether two line segments,\n * respectively joining the input points (x1,y1) -- (x2,y2)\n * and the input points (x3,y3) -- (x4,y4) intersect.\n * If the lines intersect, the output variables x, y are\n * set to coordinates of the point of intersection.\n *\n * @param {Number} x1 First line segment coordinates\n * @param {Number} y1 First line segment coordinates\n * @param {Number} x2 First line segment coordinates\n * @param {Number} x2 First line segment coordinates\n *\n * @param {Number} x3 Second line segment coordinates\n * @param {Number} y3 Second line segment coordinates\n * @param {Number} x4 Second line segment coordinates\n * @param {Number} x4 Second line segment coordinates\n *\n * @return {Object} x, y coordinates of intersection point or falsy value if no\n * intersection found..\n */\n      function intersect(\n        x1, y1, x2, y2, // first line segment\n        x3, y3, x4, y4, // second line segment\n      ) {\n        let a1,\n          a2,\n          b1,\n          b2,\n          c1,\n          c2, /* Coefficients of line eqns. */\n          r1,\n          r2,\n          r3,\n          r4, /* 'Sign' values */\n          denom,\n          offset,\n          num, /* Intermediate values */\n          result = {\n            x: 0,\n            y: 0,\n          };\n\n        /* Compute a1, b1, c1, where line joining points 1 and 2\n   * is \"a1 x  +  b1 y  +  c1  =  0\".\n   */\n        a1 = y2 - y1;\n        b1 = x1 - x2;\n        c1 = x2 * y1 - x1 * y2;\n\n        /* Compute r3 and r4.\n   */\n        r3 = a1 * x3 + b1 * y3 + c1;\n        r4 = a1 * x4 + b1 * y4 + c1;\n\n        /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n        if (r3 !== 0 && r4 !== 0 && ((r3 >= 0) === (r4 >= 4))) {\n          return null; // no intersection.\n        }\n\n        /* Compute a2, b2, c2 */\n        a2 = y4 - y3;\n        b2 = x3 - x4;\n        c2 = x4 * y3 - x3 * y4;\n\n        /* Compute r1 and r2 */\n\n        r1 = a2 * x1 + b2 * y1 + c2;\n        r2 = a2 * x2 + b2 * y2 + c2;\n\n        /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n        if (r1 !== 0 && r2 !== 0 && ((r1 >= 0) === (r2 >= 0))) {\n          return null; // no intersection;\n        }\n        /* Line segments intersect: compute intersection point.\n   */\n\n        denom = a1 * b2 - a2 * b1;\n        if (denom === 0) {\n          return null; // Actually collinear..\n        }\n\n        offset = denom < 0 ? -denom / 2 : denom / 2;\n        offset = 0.0;\n\n        /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n        num = b1 * c2 - b2 * c1;\n        result.x = (num < 0 ? num - offset : num + offset) / denom;\n\n        num = a2 * c1 - a1 * c2;\n        result.y = (num < 0 ? num - offset : num + offset) / denom;\n\n        return result;\n      }\n    }, {}],\n    4: [function (require, module, exports) {\n      module.exports.degree = require('./src/degree.js');\n      module.exports.betweenness = require('./src/betweenness.js');\n      module.exports.closeness = require('./src/closeness.js');\n      module.exports.eccentricity = require('./src/eccentricity.js');\n    }, {\n      './src/betweenness.js': 5, './src/closeness.js': 6, './src/degree.js': 7, './src/eccentricity.js': 8,\n    }],\n    5: [function (require, module, exports) {\n      module.exports = betweennes;\n\n      /**\n * I'm using http://www.inf.uni-konstanz.de/algo/publications/b-vspbc-08.pdf\n * as a reference for this implementation\n */\n      function betweennes(graph, oriented) {\n        let Q = [],\n          S = []; // Queue and Stack\n        // list of predcessors on shorteest paths from source\n        const pred = Object.create(null);\n        // distance from source\n        const dist = Object.create(null);\n        // number of shortest paths from source to key\n        const sigma = Object.create(null);\n        // dependency of source on key\n        const delta = Object.create(null);\n\n        let currentNode;\n        const centrality = Object.create(null);\n\n        graph.forEachNode(setCentralityToZero);\n        graph.forEachNode(calculateCentrality);\n\n        if (!oriented) {\n        // The centrality scores need to be divided by two if the graph is not oriented,\n        // since all shortest paths are considered twice\n          Object.keys(centrality).forEach(divideByTwo);\n        }\n\n        return centrality;\n\n        function divideByTwo(key) {\n          centrality[key] /= 2;\n        }\n\n        function setCentralityToZero(node) {\n          centrality[node.id] = 0;\n        }\n\n        function calculateCentrality(node) {\n          currentNode = node.id;\n          singleSourceShortestPath(currentNode);\n          accumulate();\n        }\n\n        function accumulate() {\n          graph.forEachNode(setDeltaToZero);\n          while (S.length) {\n            const w = S.pop();\n            const coeff = (1 + delta[w]) / sigma[w];\n            const predcessors = pred[w];\n            for (let idx = 0; idx < predcessors.length; ++idx) {\n              const v = predcessors[idx];\n              delta[v] += sigma[v] * coeff;\n            }\n            if (w !== currentNode) {\n              centrality[w] += delta[w];\n            }\n          }\n        }\n\n        function setDeltaToZero(node) {\n          delta[node.id] = 0;\n        }\n\n        function singleSourceShortestPath(source) {\n          graph.forEachNode(initNode);\n          dist[source] = 0;\n          sigma[source] = 1;\n          Q.push(source);\n\n          while (Q.length) {\n            var v = Q.shift();\n            S.push(v);\n            graph.forEachLinkedNode(v, toId, oriented);\n          }\n\n          function toId(otherNode) {\n          // NOTE: This code will also consider multi-edges, which are often\n          // ignored by popular software (Gephi/NetworkX). Depending on your use\n          // case this may not be desired and deduping needs to be performed. To\n          // save memory I'm not deduping here...\n            processNode(otherNode.id);\n          }\n\n          function initNode(node) {\n            const nodeId = node.id;\n            pred[nodeId] = []; // empty list\n            dist[nodeId] = -1;\n            sigma[nodeId] = 0;\n          }\n\n          function processNode(w) {\n          // path discovery\n            if (dist[w] === -1) {\n            // Node w is found for the first time\n              dist[w] = dist[v] + 1;\n              Q.push(w);\n            }\n            // path counting\n            if (dist[w] === dist[v] + 1) {\n            // edge (v, w) on a shortest path\n              sigma[w] += sigma[v];\n              pred[w].push(v);\n            }\n          }\n        }\n      }\n    }, {}],\n    6: [function (require, module, exports) {\n      module.exports = closeness;\n\n      /**\n * In a connected graph, the normalized closeness centrality of a node is the average\n * length of the shortest path between the node and all other nodes in the\n * graph. Thus the more central a node is, the closer it is to all other nodes.\n */\n      function closeness(graph, oriented) {\n        const Q = [];\n        // list of predcessors on shortest paths from source\n        // distance from source\n        const dist = Object.create(null);\n\n        let currentNode;\n        const centrality = Object.create(null);\n\n        graph.forEachNode(setCentralityToZero);\n        graph.forEachNode(calculateCentrality);\n\n        return centrality;\n\n        function setCentralityToZero(node) {\n          centrality[node.id] = 0;\n        }\n\n        function calculateCentrality(node) {\n          currentNode = node.id;\n          singleSourceShortestPath(currentNode);\n          accumulate();\n        }\n\n        function accumulate() {\n        // Add all distances for node to array, excluding -1s\n          const distances = Object.keys(dist).map(key => dist[key]).filter(val => val !== -1);\n          // Set number of reachable nodes\n          const reachableNodesTotal = distances.length;\n          // Compute sum of all distances for node\n          const totalDistance = distances.reduce((a, b) => a + b);\n          if (totalDistance > 0) {\n            centrality[currentNode] = ((reachableNodesTotal - 1) / totalDistance);\n          } else {\n            centrality[currentNode] = 0;\n          }\n        }\n\n        function singleSourceShortestPath(source) {\n          graph.forEachNode(initNode);\n          dist[source] = 0;\n          Q.push(source);\n\n          while (Q.length) {\n            var v = Q.shift();\n            graph.forEachLinkedNode(v, processNode, oriented);\n          }\n\n          function initNode(node) {\n            const nodeId = node.id;\n            dist[nodeId] = -1;\n          }\n\n          function processNode(otherNode) {\n            const w = otherNode.id;\n            if (dist[w] === -1) {\n            // Node w is found for the first time\n              dist[w] = dist[v] + 1;\n              Q.push(w);\n            }\n          }\n        }\n      }\n    }, {}],\n    7: [function (require, module, exports) {\n      module.exports = degree;\n\n      /**\n * Calculates graph nodes degree centrality (in/out or both).\n *\n * @see http://en.wikipedia.org/wiki/Centrality#Degree_centrality\n *\n * @param {ngraph.graph} graph object for which we are calculating centrality.\n * @param {string} [kind=both] What kind of degree centrality needs to be calculated:\n *   'in'    - calculate in-degree centrality\n *   'out'   - calculate out-degree centrality\n *   'inout' - (default) generic degree centrality is calculated\n */\n      function degree(graph, kind) {\n        let getNodeDegree;\n        const result = Object.create(null);\n\n        kind = (kind || 'both').toLowerCase();\n        if (kind === 'both' || kind === 'inout') {\n          getNodeDegree = inoutDegreeCalculator;\n        } else if (kind === 'in') {\n          getNodeDegree = inDegreeCalculator;\n        } else if (kind === 'out') {\n          getNodeDegree = outDegreeCalculator;\n        } else {\n          throw new Error('Expected centrality degree kind is: in, out or both');\n        }\n\n        graph.forEachNode(calculateNodeDegree);\n\n        return result;\n\n        function calculateNodeDegree(node) {\n          const links = graph.getLinks(node.id);\n          result[node.id] = getNodeDegree(links, node.id);\n        }\n      }\n\n      function inDegreeCalculator(links, nodeId) {\n        let total = 0;\n        if (!links) return total;\n\n        for (let i = 0; i < links.length; i += 1) {\n          total += (links[i].toId === nodeId) ? 1 : 0;\n        }\n        return total;\n      }\n\n      function outDegreeCalculator(links, nodeId) {\n        let total = 0;\n        if (!links) return total;\n\n        for (let i = 0; i < links.length; i += 1) {\n          total += (links[i].fromId === nodeId) ? 1 : 0;\n        }\n        return total;\n      }\n\n      function inoutDegreeCalculator(links) {\n        if (!links) return 0;\n\n        return links.length;\n      }\n    }, {}],\n    8: [function (require, module, exports) {\n      module.exports = eccentricity;\n\n      /**\n * The eccentricity centrality of a node is the greatest distance between that node and\n * any other node in the network.\n */\n      function eccentricity(graph, oriented) {\n        const Q = [];\n        // distance from source\n        const dist = Object.create(null);\n\n        let currentNode;\n        const centrality = Object.create(null);\n\n        graph.forEachNode(setCentralityToZero);\n        graph.forEachNode(calculateCentrality);\n\n        return centrality;\n\n        function setCentralityToZero(node) {\n          centrality[node.id] = 0;\n        }\n\n        function calculateCentrality(node) {\n          currentNode = node.id;\n          singleSourceShortestPath(currentNode);\n          accumulate();\n        }\n\n        function accumulate() {\n          let maxDist = 0;\n          Object.keys(dist).forEach((key) => {\n            const val = dist[key];\n            if (maxDist < val) maxDist = val;\n          });\n\n          centrality[currentNode] = maxDist;\n        }\n\n        function singleSourceShortestPath(source) {\n          graph.forEachNode(initNode);\n          dist[source] = 0;\n          Q.push(source);\n\n          while (Q.length) {\n            var v = Q.shift();\n            graph.forEachLinkedNode(v, processNode, oriented);\n          }\n\n          function initNode(node) {\n            const nodeId = node.id;\n            dist[nodeId] = -1;\n          }\n\n          function processNode(otherNode) {\n            const w = otherNode.id;\n            if (dist[w] === -1) {\n            // Node w is found for the first time\n              dist[w] = dist[v] + 1;\n              Q.push(w);\n            }\n          }\n        }\n      }\n    }, {}],\n    9: [function (require, module, exports) {\n      module.exports = function (subject) {\n        validateSubject(subject);\n\n        const eventsStorage = createEventsStorage(subject);\n        subject.on = eventsStorage.on;\n        subject.off = eventsStorage.off;\n        subject.fire = eventsStorage.fire;\n        return subject;\n      };\n\n      function createEventsStorage(subject) {\n      // Store all event listeners to this hash. Key is event name, value is array\n      // of callback records.\n      //\n      // A callback record consists of callback function and its optional context:\n      // { 'eventName' => [{callback: function, ctx: object}] }\n        let registeredEvents = Object.create(null);\n\n        return {\n          on(eventName, callback, ctx) {\n            if (typeof callback !== 'function') {\n              throw new Error('callback is expected to be a function');\n            }\n            let handlers = registeredEvents[eventName];\n            if (!handlers) {\n              handlers = registeredEvents[eventName] = [];\n            }\n            handlers.push({ callback, ctx });\n\n            return subject;\n          },\n\n          off(eventName, callback) {\n            const wantToRemoveAll = (typeof eventName === 'undefined');\n            if (wantToRemoveAll) {\n              // Killing old events storage should be enough in this case:\n              registeredEvents = Object.create(null);\n              return subject;\n            }\n\n            if (registeredEvents[eventName]) {\n              const deleteAllCallbacksForEvent = (typeof callback !== 'function');\n              if (deleteAllCallbacksForEvent) {\n                delete registeredEvents[eventName];\n              } else {\n                const callbacks = registeredEvents[eventName];\n                for (let i = 0; i < callbacks.length; ++i) {\n                  if (callbacks[i].callback === callback) {\n                    callbacks.splice(i, 1);\n                  }\n                }\n              }\n            }\n\n            return subject;\n          },\n\n          fire(eventName) {\n            const callbacks = registeredEvents[eventName];\n            if (!callbacks) {\n              return subject;\n            }\n\n            let fireArguments;\n            if (arguments.length > 1) {\n              fireArguments = Array.prototype.splice.call(arguments, 1);\n            }\n            for (let i = 0; i < callbacks.length; ++i) {\n              const callbackInfo = callbacks[i];\n              callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n            }\n\n            return subject;\n          },\n        };\n      }\n\n      function validateSubject(subject) {\n        if (!subject) {\n          throw new Error('Eventify cannot use falsy object as events subject');\n        }\n        const reservedWords = ['on', 'fire', 'off'];\n        for (let i = 0; i < reservedWords.length; ++i) {\n          if (subject.hasOwnProperty(reservedWords[i])) {\n            throw new Error(`Subject cannot be eventified, since it already has property '${reservedWords[i]}'`);\n          }\n        }\n      }\n    }, {}],\n    10: [function (require, module, exports) {\n      module.exports = exposeProperties;\n\n      /**\n * Augments `target` object with getter/setter functions, which modify settings\n *\n * @example\n *  var target = {};\n *  exposeProperties({ age: 42}, target);\n *  target.age(); // returns 42\n *  target.age(24); // make age 24;\n *\n *  var filteredTarget = {};\n *  exposeProperties({ age: 42, name: 'John'}, filteredTarget, ['name']);\n *  filteredTarget.name(); // returns 'John'\n *  filteredTarget.age === undefined; // true\n */\n      function exposeProperties(settings, target, filter) {\n        const needsFilter = Object.prototype.toString.call(filter) === '[object Array]';\n        if (needsFilter) {\n          for (let i = 0; i < filter.length; ++i) {\n            augment(settings, target, filter[i]);\n          }\n        } else {\n          for (const key in settings) {\n            augment(settings, target, key);\n          }\n        }\n      }\n\n      function augment(source, target, key) {\n        if (source.hasOwnProperty(key)) {\n          if (typeof target[key] === 'function') {\n          // this accessor is already defined. Ignore it\n            return;\n          }\n          target[key] = function (value) {\n            if (value !== undefined) {\n              source[key] = value;\n              return target;\n            }\n            return source[key];\n          };\n        }\n      }\n    }, {}],\n    11: [function (require, module, exports) {\n      module.exports = createLayout;\n      module.exports.simulator = require('ngraph.physics.simulator');\n\n      const eventify = require('ngraph.events');\n\n      /**\n * Creates force based layout for a given graph.\n *\n * @param {ngraph.graph} graph which needs to be laid out\n * @param {object} physicsSettings if you need custom settings\n * for physics simulator you can pass your own settings here. If it's not passed\n * a default one will be created.\n */\n      function createLayout(graph, physicsSettings) {\n        if (!graph) {\n          throw new Error('Graph structure cannot be undefined');\n        }\n\n        const createSimulator = require('ngraph.physics.simulator');\n        const physicsSimulator = createSimulator(physicsSettings);\n\n        let nodeMass = defaultNodeMass;\n        if (physicsSettings && typeof physicsSettings.nodeMass === 'function') {\n          nodeMass = physicsSettings.nodeMass;\n        }\n\n        const nodeBodies = Object.create(null);\n        const springs = {};\n        let bodiesCount = 0;\n\n        const springTransform = physicsSimulator.settings.springTransform || noop;\n\n        // Initialize physics with what we have in the graph:\n        initPhysics();\n        listenToEvents();\n\n        let wasStable = false;\n\n        var api = {\n        /**\n     * Performs one step of iterative layout algorithm\n     *\n     * @returns {boolean} true if the system should be considered stable; Flase otherwise.\n     * The system is stable if no further call to `step()` can improve the layout.\n     */\n          step() {\n            if (bodiesCount === 0) return true; // TODO: This will never fire 'stable'\n\n            const lastMove = physicsSimulator.step();\n\n            // Save the movement in case if someone wants to query it in the step\n            // callback.\n            api.lastMove = lastMove;\n\n            // Allow listeners to perform low-level actions after nodes are updated.\n            api.fire('step');\n\n            const ratio = lastMove / bodiesCount;\n            const isStableNow = ratio <= 0.01; // TODO: The number is somewhat arbitrary...\n\n            if (wasStable !== isStableNow) {\n              wasStable = isStableNow;\n              onStableChanged(isStableNow);\n            }\n\n            return isStableNow;\n          },\n\n          /**\n     * For a given `nodeId` returns position\n     */\n          getNodePosition(nodeId) {\n            return getInitializedBody(nodeId).pos;\n          },\n\n          /**\n     * Sets position of a node to a given coordinates\n     * @param {string} nodeId node identifier\n     * @param {number} x position of a node\n     * @param {number} y position of a node\n     * @param {number=} z position of node (only if applicable to body)\n     */\n          setNodePosition(nodeId) {\n            const body = getInitializedBody(nodeId);\n            body.setPosition(...Array.prototype.slice.call(arguments, 1));\n            physicsSimulator.invalidateBBox();\n          },\n\n          /**\n     * @returns {Object} Link position by link id\n     * @returns {Object.from} {x, y} coordinates of link start\n     * @returns {Object.to} {x, y} coordinates of link end\n     */\n          getLinkPosition(linkId) {\n            const spring = springs[linkId];\n            if (spring) {\n              return {\n                from: spring.from.pos,\n                to: spring.to.pos,\n              };\n            }\n          },\n\n          /**\n     * @returns {Object} area required to fit in the graph. Object contains\n     * `x1`, `y1` - top left coordinates\n     * `x2`, `y2` - bottom right coordinates\n     */\n          getGraphRect() {\n            return physicsSimulator.getBBox();\n          },\n\n          /**\n     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)\n     */\n          forEachBody,\n\n          /*\n     * Requests layout algorithm to pin/unpin node to its current position\n     * Pinned nodes should not be affected by layout algorithm and always\n     * remain at their position\n     */\n          pinNode(node, isPinned) {\n            const body = getInitializedBody(node.id);\n            body.isPinned = !!isPinned;\n          },\n\n          /**\n     * Checks whether given graph's node is currently pinned\n     */\n          isNodePinned(node) {\n            return getInitializedBody(node.id).isPinned;\n          },\n\n          /**\n     * Request to release all resources\n     */\n          dispose() {\n            graph.off('changed', onGraphChanged);\n            api.fire('disposed');\n          },\n\n          /**\n     * Gets physical body for a given node id. If node is not found undefined\n     * value is returned.\n     */\n          getBody,\n\n          /**\n     * Gets spring for a given edge.\n     *\n     * @param {string} linkId link identifer. If two arguments are passed then\n     * this argument is treated as formNodeId\n     * @param {string=} toId when defined this parameter denotes head of the link\n     * and first argument is trated as tail of the link (fromId)\n     */\n          getSpring,\n\n          /**\n     * [Read only] Gets current physics simulator\n     */\n          simulator: physicsSimulator,\n\n          /**\n     * Gets the graph that was used for layout\n     */\n          graph,\n\n          /**\n     * Gets amount of movement performed during last step opeartion\n     */\n          lastMove: 0,\n        };\n\n        eventify(api);\n\n        return api;\n\n        function forEachBody(cb) {\n          Object.keys(nodeBodies).forEach((bodyId) => {\n            cb(nodeBodies[bodyId], bodyId);\n          });\n        }\n\n        function getSpring(fromId, toId) {\n          let linkId;\n          if (toId === undefined) {\n            if (typeof fromId !== 'object') {\n            // assume fromId as a linkId:\n              linkId = fromId;\n            } else {\n            // assume fromId to be a link object:\n              linkId = fromId.id;\n            }\n          } else {\n          // toId is defined, should grab link:\n            const link = graph.hasLink(fromId, toId);\n            if (!link) return;\n            linkId = link.id;\n          }\n\n          return springs[linkId];\n        }\n\n        function getBody(nodeId) {\n          return nodeBodies[nodeId];\n        }\n\n        function listenToEvents() {\n          graph.on('changed', onGraphChanged);\n        }\n\n        function onStableChanged(isStable) {\n          api.fire('stable', isStable);\n        }\n\n        function onGraphChanged(changes) {\n          for (let i = 0; i < changes.length; ++i) {\n            const change = changes[i];\n            if (change.changeType === 'add') {\n              if (change.node) {\n                initBody(change.node.id);\n              }\n              if (change.link) {\n                initLink(change.link);\n              }\n            } else if (change.changeType === 'remove') {\n              if (change.node) {\n                releaseNode(change.node);\n              }\n              if (change.link) {\n                releaseLink(change.link);\n              }\n            }\n          }\n          bodiesCount = graph.getNodesCount();\n        }\n\n        function initPhysics() {\n          bodiesCount = 0;\n\n          graph.forEachNode((node) => {\n            initBody(node.id);\n            bodiesCount += 1;\n          });\n\n          graph.forEachLink(initLink);\n        }\n\n        function initBody(nodeId) {\n          let body = nodeBodies[nodeId];\n          if (!body) {\n            const node = graph.getNode(nodeId);\n            if (!node) {\n              throw new Error('initBody() was called with unknown node id');\n            }\n\n            let pos = node.position;\n            if (!pos) {\n              const neighbors = getNeighborBodies(node);\n              pos = physicsSimulator.getBestNewBodyPosition(neighbors);\n            }\n\n            body = physicsSimulator.addBodyAt(pos);\n            body.id = nodeId;\n\n            nodeBodies[nodeId] = body;\n            updateBodyMass(nodeId);\n\n            if (isNodeOriginallyPinned(node)) {\n              body.isPinned = true;\n            }\n          }\n        }\n\n        function releaseNode(node) {\n          const nodeId = node.id;\n          const body = nodeBodies[nodeId];\n          if (body) {\n            nodeBodies[nodeId] = null;\n            delete nodeBodies[nodeId];\n\n            physicsSimulator.removeBody(body);\n          }\n        }\n\n        function initLink(link) {\n          updateBodyMass(link.fromId);\n          updateBodyMass(link.toId);\n\n          let fromBody = nodeBodies[link.fromId],\n            toBody = nodeBodies[link.toId],\n            spring = physicsSimulator.addSpring(fromBody, toBody, link.length);\n\n          springTransform(link, spring);\n\n          springs[link.id] = spring;\n        }\n\n        function releaseLink(link) {\n          const spring = springs[link.id];\n          if (spring) {\n            let from = graph.getNode(link.fromId),\n              to = graph.getNode(link.toId);\n\n            if (from) updateBodyMass(from.id);\n            if (to) updateBodyMass(to.id);\n\n            delete springs[link.id];\n\n            physicsSimulator.removeSpring(spring);\n          }\n        }\n\n        function getNeighborBodies(node) {\n        // TODO: Could probably be done better on memory\n          const neighbors = [];\n          if (!node.links) {\n            return neighbors;\n          }\n          const maxNeighbors = Math.min(node.links.length, 2);\n          for (let i = 0; i < maxNeighbors; ++i) {\n            const link = node.links[i];\n            const otherBody = link.fromId !== node.id ? nodeBodies[link.fromId] : nodeBodies[link.toId];\n            if (otherBody && otherBody.pos) {\n              neighbors.push(otherBody);\n            }\n          }\n\n          return neighbors;\n        }\n\n        function updateBodyMass(nodeId) {\n          const body = nodeBodies[nodeId];\n          body.mass = nodeMass(nodeId);\n          if (Number.isNaN(body.mass)) {\n            throw new Error('Node mass should be a number');\n          }\n        }\n\n        /**\n   * Checks whether graph node has in its settings pinned attribute,\n   * which means layout algorithm cannot move it. Node can be preconfigured\n   * as pinned, if it has \"isPinned\" attribute, or when node.data has it.\n   *\n   * @param {Object} node a graph node to check\n   * @return {Boolean} true if node should be treated as pinned; false otherwise.\n   */\n        function isNodeOriginallyPinned(node) {\n          return (node && (node.isPinned || (node.data && node.data.isPinned)));\n        }\n\n        function getInitializedBody(nodeId) {\n          let body = nodeBodies[nodeId];\n          if (!body) {\n            initBody(nodeId);\n            body = nodeBodies[nodeId];\n          }\n          return body;\n        }\n\n        /**\n   * Calculates mass of a body, which corresponds to node with given id.\n   *\n   * @param {String|Number} nodeId identifier of a node, for which body mass needs to be calculated\n   * @returns {Number} recommended mass of the body;\n   */\n        function defaultNodeMass(nodeId) {\n          const links = graph.getLinks(nodeId);\n          if (!links) return 1;\n          return 1 + links.length / 3.0;\n        }\n      }\n\n      function noop() { }\n    }, { 'ngraph.events': 12, 'ngraph.physics.simulator': 19 }],\n    12: [function (require, module, exports) {\n      arguments[4][9][0].apply(exports, arguments);\n    }, { dup: 9 }],\n    13: [function (require, module, exports) {\n      module.exports = load;\n\n      const createGraph = require('ngraph.graph');\n\n      function load(jsonGraph, nodeTransform, linkTransform) {\n        let stored;\n        nodeTransform = nodeTransform || id;\n        linkTransform = linkTransform || id;\n        if (typeof jsonGraph === 'string') {\n          stored = JSON.parse(jsonGraph);\n        } else {\n          stored = jsonGraph;\n        }\n\n        let graph = createGraph(),\n          i;\n\n        if (stored.links === undefined || stored.nodes === undefined) {\n          throw new Error('Cannot load graph without links and nodes');\n        }\n\n        for (i = 0; i < stored.nodes.length; ++i) {\n          const parsedNode = nodeTransform(stored.nodes[i]);\n          if (!parsedNode.hasOwnProperty('id')) {\n            throw new Error('Graph node format is invalid: Node id is missing');\n          }\n\n          graph.addNode(parsedNode.id, parsedNode.data);\n        }\n\n        for (i = 0; i < stored.links.length; ++i) {\n          const link = linkTransform(stored.links[i]);\n          if (!link.hasOwnProperty('fromId') || !link.hasOwnProperty('toId')) {\n            throw new Error('Graph link format is invalid. Both fromId and toId are required');\n          }\n\n          graph.addLink(link.fromId, link.toId, link.data);\n        }\n\n        return graph;\n      }\n\n      function id(x) { return x; }\n    }, { 'ngraph.graph': 16 }],\n    14: [function (require, module, exports) {\n      const createGraph = require('ngraph.graph');\n\n      module.exports = factory(createGraph);\n\n      // Allow other developers have their own createGraph\n      module.exports.factory = factory;\n\n      function factory(createGraph) {\n        return {\n          ladder,\n          complete,\n          completeBipartite,\n          balancedBinTree,\n          path,\n          circularLadder,\n          grid,\n          grid3,\n          noLinks,\n          wattsStrogatz,\n          cliqueCircle,\n        };\n\n\n        function ladder(n) {\n        /**\n  * Ladder graph is a graph in form of ladder\n  * @param {Number} n Represents number of steps in the ladder\n  */\n          if (!n || n < 0) {\n            throw new Error('Invalid number of nodes');\n          }\n\n          let g = createGraph(),\n            i;\n\n          for (i = 0; i < n - 1; ++i) {\n            g.addLink(i, i + 1);\n            // first row\n            g.addLink(n + i, n + i + 1);\n            // second row\n            g.addLink(i, n + i);\n          // ladder's step\n          }\n\n          g.addLink(n - 1, 2 * n - 1);\n          // last step in the ladder;\n\n          return g;\n        }\n\n        function circularLadder(n) {\n        /**\n  * Circular ladder with n steps.\n  *\n  * @param {Number} n of steps in the ladder.\n  */\n          if (!n || n < 0) {\n            throw new Error('Invalid number of nodes');\n          }\n\n          const g = ladder(n);\n\n          g.addLink(0, n - 1);\n          g.addLink(n, 2 * n - 1);\n          return g;\n        }\n\n        function complete(n) {\n        /**\n  * Complete graph Kn.\n  *\n  * @param {Number} n represents number of nodes in the complete graph.\n  */\n          if (!n || n < 1) {\n            throw new Error('At least two nodes are expected for complete graph');\n          }\n\n          let g = createGraph(),\n            i,\n            j;\n\n          for (i = 0; i < n; ++i) {\n            for (j = i + 1; j < n; ++j) {\n              if (i !== j) {\n                g.addLink(i, j);\n              }\n            }\n          }\n\n          return g;\n        }\n\n        function completeBipartite(n, m) {\n        /**\n  * Complete bipartite graph K n,m. Each node in the\n  * first partition is connected to all nodes in the second partition.\n  *\n  * @param {Number} n represents number of nodes in the first graph partition\n  * @param {Number} m represents number of nodes in the second graph partition\n  */\n          if (!n || !m || n < 0 || m < 0) {\n            throw new Error('Graph dimensions are invalid. Number of nodes in each partition should be greater than 0');\n          }\n\n          let g = createGraph(),\n            i,\n            j;\n\n          for (i = 0; i < n; ++i) {\n            for (j = n; j < n + m; ++j) {\n              g.addLink(i, j);\n            }\n          }\n\n          return g;\n        }\n\n        function path(n) {\n        /**\n  * Path graph with n steps.\n  *\n  * @param {Number} n number of nodes in the path\n  */\n          if (!n || n < 0) {\n            throw new Error('Invalid number of nodes');\n          }\n\n          let g = createGraph(),\n            i;\n\n          g.addNode(0);\n\n          for (i = 1; i < n; ++i) {\n            g.addLink(i - 1, i);\n          }\n\n          return g;\n        }\n\n\n        function grid(n, m) {\n        /**\n  * Grid graph with n rows and m columns.\n  *\n  * @param {Number} n of rows in the graph.\n  * @param {Number} m of columns in the graph.\n  */\n          if (n < 1 || m < 1) {\n            throw new Error('Invalid number of nodes in grid graph');\n          }\n          let g = createGraph(),\n            i,\n            j;\n          if (n === 1 && m === 1) {\n            g.addNode(0);\n            return g;\n          }\n\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < m; ++j) {\n              const node = i + j * n;\n              if (i > 0) { g.addLink(node, i - 1 + j * n); }\n              if (j > 0) { g.addLink(node, i + (j - 1) * n); }\n            }\n          }\n\n          return g;\n        }\n\n        function grid3(n, m, z) {\n        /**\n  * 3D grid with n rows and m columns and z levels.\n  *\n  * @param {Number} n of rows in the graph.\n  * @param {Number} m of columns in the graph.\n  * @param {Number} z of levels in the graph.\n  */\n          if (n < 1 || m < 1 || z < 1) {\n            throw new Error('Invalid number of nodes in grid3 graph');\n          }\n          let g = createGraph(),\n            i,\n            j,\n            k;\n\n          if (n === 1 && m === 1 && z === 1) {\n            g.addNode(0);\n            return g;\n          }\n\n          for (k = 0; k < z; ++k) {\n            for (i = 0; i < n; ++i) {\n              for (j = 0; j < m; ++j) {\n                const level = k * n * m;\n                const node = i + j * n + level;\n                if (i > 0) { g.addLink(node, i - 1 + j * n + level); }\n                if (j > 0) { g.addLink(node, i + (j - 1) * n + level); }\n                if (k > 0) { g.addLink(node, i + j * n + (k - 1) * n * m); }\n              }\n            }\n          }\n\n          return g;\n        }\n\n        function balancedBinTree(n) {\n        /**\n  * Balanced binary tree with n levels.\n  *\n  * @param {Number} n of levels in the binary tree\n  */\n          if (n < 0) {\n            throw new Error('Invalid number of nodes in balanced tree');\n          }\n          let g = createGraph(),\n            count = Math.pow(2, n),\n            level;\n\n          if (n === 0) {\n            g.addNode(1);\n          }\n\n          for (level = 1; level < count; ++level) {\n            let root = level,\n              left = root * 2,\n              right = root * 2 + 1;\n\n            g.addLink(root, left);\n            g.addLink(root, right);\n          }\n\n          return g;\n        }\n\n        function noLinks(n) {\n        /**\n  * Graph with no links\n  *\n  * @param {Number} n of nodes in the graph\n  */\n          if (n < 0) {\n            throw new Error('Number of nodes should be >= 0');\n          }\n\n          let g = createGraph(),\n            i;\n          for (i = 0; i < n; ++i) {\n            g.addNode(i);\n          }\n\n          return g;\n        }\n\n        function cliqueCircle(cliqueCount, cliqueSize) {\n        /**\n  * A circular graph with cliques instead of individual nodes\n  *\n  * @param {Number} cliqueCount number of cliques inside circle\n  * @param {Number} cliqueSize number of nodes inside each clique\n  */\n\n          if (cliqueCount < 1) throw new Error('Invalid number of cliqueCount in cliqueCircle');\n          if (cliqueSize < 1) throw new Error('Invalid number of cliqueSize in cliqueCircle');\n\n          const graph = createGraph();\n\n          for (let i = 0; i < cliqueCount; ++i) {\n            appendClique(cliqueSize, i * cliqueSize);\n\n            if (i > 0) {\n              graph.addLink(i * cliqueSize, i * cliqueSize - 1);\n            }\n          }\n          graph.addLink(0, graph.getNodesCount() - 1);\n\n          return graph;\n\n          function appendClique(size, from) {\n            for (var i = 0; i < size; ++i) {\n              graph.addNode(i + from);\n            }\n\n            for (var i = 0; i < size; ++i) {\n              for (let j = i + 1; j < size; ++j) {\n                graph.addLink(i + from, j + from);\n              }\n            }\n          }\n        }\n\n        function wattsStrogatz(n, k, p, seed) {\n        /**\n  * Watts-Strogatz small-world graph.\n  *\n  * @param {Number} n The number of nodes\n  * @param {Number} k Each node is connected to k nearest neighbors in ring topology\n  * @param {Number} p The probability of rewiring each edge\n\n  * @see https://github.com/networkx/networkx/blob/master/networkx/generators/random_graphs.py\n  */\n          if (k >= n) throw new Error('Choose smaller `k`. It cannot be larger than number of nodes `n`');\n\n\n          const random = require('ngraph.random').random(seed || 42);\n\n          let g = createGraph(),\n            i,\n            to;\n          for (i = 0; i < n; ++i) {\n            g.addNode(i);\n          }\n\n          // connect each node to k/2 neighbors\n          const neighborsSize = Math.floor(k / 2 + 1);\n          for (var j = 1; j < neighborsSize; ++j) {\n            for (i = 0; i < n; ++i) {\n              to = (j + i) % n;\n              g.addLink(i, to);\n            }\n          }\n\n          // rewire edges from each node\n          // loop over all nodes in order (label) and neighbors in order (distance)\n          // no self loops or multiple edges allowed\n          for (j = 1; j < neighborsSize; ++j) {\n            for (i = 0; i < n; ++i) {\n              if (random.nextDouble() < p) {\n                const from = i;\n                to = (j + i) % n;\n\n                let newTo = random.next(n);\n                let needsRewire = (newTo === from || g.hasLink(from, newTo));\n                if (needsRewire && g.getLinks(from).length === n - 1) {\n                // we cannot rewire this node, it has too many links.\n                  continue;\n                }\n                // Enforce no self-loops or multiple edges\n                while (needsRewire) {\n                  newTo = random.next(n);\n                  needsRewire = (newTo === from || g.hasLink(from, newTo));\n                }\n                const link = g.hasLink(from, to);\n                g.removeLink(link);\n                g.addLink(from, newTo);\n              }\n            }\n          }\n\n          return g;\n        }\n      }\n    }, { 'ngraph.graph': 16, 'ngraph.random': 15 }],\n    15: [function (require, module, exports) {\n      module.exports = random;\n\n      // TODO: Deprecate?\n      module.exports.random = random,\n      module.exports.randomIterator = randomIterator;\n\n      /**\n * Creates seeded PRNG with two methods:\n *   next() and nextDouble()\n */\n      function random(inputSeed) {\n        const seed = typeof inputSeed === 'number' ? inputSeed : (+new Date());\n        return new Generator(seed);\n      }\n\n      function Generator(seed) {\n        this.seed = seed;\n      }\n\n      /**\n  * Generates random integer number in the range from 0 (inclusive) to maxValue (exclusive)\n  *\n  * @param maxValue Number REQUIRED. Omitting this number will result in NaN values from PRNG.\n  */\n      Generator.prototype.next = next;\n\n      /**\n  * Generates random double number in the range from 0 (inclusive) to 1 (exclusive)\n  * This function is the same as Math.random() (except that it could be seeded)\n  */\n      Generator.prototype.nextDouble = nextDouble;\n\n      /**\n * Returns a random real number uniformly in [0, 1)\n */\n      Generator.prototype.uniform = nextDouble;\n\n      Generator.prototype.gaussian = gaussian;\n\n      function gaussian() {\n      // use the polar form of the Box-Muller transform\n      // based on https://introcs.cs.princeton.edu/java/23recursion/StdRandom.java\n        let r,\n          x,\n          y;\n        do {\n          x = this.nextDouble() * 2 - 1;\n          y = this.nextDouble() * 2 - 1;\n          r = x * x + y * y;\n        } while (r >= 1 || r === 0);\n\n        return x * Math.sqrt(-2 * Math.log(r) / r);\n      }\n\n      function nextDouble() {\n        let seed = this.seed;\n        // Robert Jenkins' 32 bit integer hash function.\n        seed = ((seed + 0x7ed55d16) + (seed << 12)) & 0xffffffff;\n        seed = ((seed ^ 0xc761c23c) ^ (seed >>> 19)) & 0xffffffff;\n        seed = ((seed + 0x165667b1) + (seed << 5)) & 0xffffffff;\n        seed = ((seed + 0xd3a2646c) ^ (seed << 9)) & 0xffffffff;\n        seed = ((seed + 0xfd7046c5) + (seed << 3)) & 0xffffffff;\n        seed = ((seed ^ 0xb55a4f09) ^ (seed >>> 16)) & 0xffffffff;\n        this.seed = seed;\n        return (seed & 0xfffffff) / 0x10000000;\n      }\n\n      function next(maxValue) {\n        return Math.floor(this.nextDouble() * maxValue);\n      }\n\n      /*\n * Creates iterator over array, which returns items of array in random order\n * Time complexity is guaranteed to be O(n);\n */\n      function randomIterator(array, customRandom) {\n        const localRandom = customRandom || random();\n        if (typeof localRandom.next !== 'function') {\n          throw new Error('customRandom does not match expected API: next() function is missing');\n        }\n\n        return {\n          forEach,\n\n          /**\n     * Shuffles array randomly, in place.\n     */\n          shuffle,\n        };\n\n        function shuffle() {\n          let i,\n            j,\n            t;\n          for (i = array.length - 1; i > 0; --i) {\n            j = localRandom.next(i + 1); // i inclusive\n            t = array[j];\n            array[j] = array[i];\n            array[i] = t;\n          }\n\n          return array;\n        }\n\n        function forEach(callback) {\n          let i,\n            j,\n            t;\n          for (i = array.length - 1; i > 0; --i) {\n            j = localRandom.next(i + 1); // i inclusive\n            t = array[j];\n            array[j] = array[i];\n            array[i] = t;\n\n            callback(t);\n          }\n\n          if (array.length) {\n            callback(array[0]);\n          }\n        }\n      }\n    }, {}],\n    16: [function (require, module, exports) {\n    /**\n * @fileOverview Contains definition of the core graph object.\n */\n\n    // TODO: need to change storage layer:\n    // 1. Be able to get all nodes O(1)\n    // 2. Be able to get number of links O(1)\n\n    /**\n * @example\n *  var graph = require('ngraph.graph')();\n *  graph.addNode(1);     // graph has one node.\n *  graph.addLink(2, 3);  // now graph contains three nodes and one link.\n *\n */\n      module.exports = createGraph;\n\n      const eventify = require('ngraph.events');\n\n      /**\n * Creates a new graph\n */\n      function createGraph(options) {\n      // Graph structure is maintained as dictionary of nodes\n      // and array of links. Each node has 'links' property which\n      // hold all links related to that node. And general links\n      // array is used to speed up all links enumeration. This is inefficient\n      // in terms of memory, but simplifies coding.\n        options = options || {};\n        if ('uniqueLinkId' in options) {\n          console.warn(\n            'ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\\n' +\n      'Use `multigraph` option instead\\n',\n            '\\n',\n            'Note: there is also change in default behavior: From now own each graph\\n' +\n      'is considered to be not a multigraph by default (each edge is unique).',\n          );\n\n          options.multigraph = options.uniqueLinkId;\n        }\n\n        // Dear reader, the non-multigraphs do not guarantee that there is only\n        // one link for a given pair of node. When this option is set to false\n        // we can save some memory and CPU (18% faster for non-multigraph);\n        if (options.multigraph === undefined) options.multigraph = false;\n\n        let nodes = typeof Object.create === 'function' ? Object.create(null) : {},\n          links = [],\n          // Hash of multi-edges. Used to track ids of edges between same nodes\n          multiEdges = {},\n          nodesCount = 0,\n          suspendEvents = 0,\n\n          forEachNode = createNodeIterator(),\n          createLink = options.multigraph ? createUniqueLink : createSingleLink,\n\n          // Our graph API provides means to listen to graph changes. Users can subscribe\n          // to be notified about changes in the graph by using `on` method. However\n          // in some cases they don't use it. To avoid unnecessary memory consumption\n          // we will not record graph changes until we have at least one subscriber.\n          // Code below supports this optimization.\n          //\n          // Accumulates all changes made during graph updates.\n          // Each change element contains:\n          //  changeType - one of the strings: 'add', 'remove' or 'update';\n          //  node - if change is related to node this property is set to changed graph's node;\n          //  link - if change is related to link this property is set to changed graph's link;\n          changes = [],\n          recordLinkChange = noop,\n          recordNodeChange = noop,\n          enterModification = noop,\n          exitModification = noop;\n\n        // this is our public API:\n        const graphPart = {\n        /**\n     * Adds node to the graph. If node with given id already exists in the graph\n     * its data is extended with whatever comes in 'data' argument.\n     *\n     * @param nodeId the node's identifier. A string or number is preferred.\n     * @param [data] additional data for the node being added. If node already\n     *   exists its data object is augmented with the new one.\n     *\n     * @return {node} The newly added node or node with given id if it already exists.\n     */\n          addNode,\n\n          /**\n     * Adds a link to the graph. The function always create a new\n     * link between two nodes. If one of the nodes does not exists\n     * a new node is created.\n     *\n     * @param fromId link start node id;\n     * @param toId link end node id;\n     * @param [data] additional data to be set on the new link;\n     *\n     * @return {link} The newly created link\n     */\n          addLink,\n\n          /**\n     * Removes link from the graph. If link does not exist does nothing.\n     *\n     * @param link - object returned by addLink() or getLinks() methods.\n     *\n     * @returns true if link was removed; false otherwise.\n     */\n          removeLink,\n\n          /**\n     * Removes node with given id from the graph. If node does not exist in the graph\n     * does nothing.\n     *\n     * @param nodeId node's identifier passed to addNode() function.\n     *\n     * @returns true if node was removed; false otherwise.\n     */\n          removeNode,\n\n          /**\n     * Gets node with given identifier. If node does not exist undefined value is returned.\n     *\n     * @param nodeId requested node identifier;\n     *\n     * @return {node} in with requested identifier or undefined if no such node exists.\n     */\n          getNode,\n          getNodesWithId,\n          getNodeCount,\n          getAllNodes,\n          getAllLinks,\n          getAllLinkedNodes,\n          /**\n     * Gets number of nodes in this graph.\n     *\n     * @return number of nodes in the graph.\n     */\n          getNodesCount() {\n            return nodesCount;\n          },\n\n          /**\n     * Gets total number of links in the graph.\n     */\n          getLinksCount() {\n            return links.length;\n          },\n\n          /**\n     * Gets all links (inbound and outbound) from the node with given id.\n     * If node with given id is not found null is returned.\n     *\n     * @param nodeId requested node identifier.\n     *\n     * @return Array of links from and to requested node if such node exists;\n     *   otherwise null is returned.\n     */\n          getLinks,\n\n          /**\n     * Invokes callback on each node of the graph.\n     *\n     * @param {Function(node)} callback Function to be invoked. The function\n     *   is passed one argument: visited node.\n     */\n          forEachNode,\n\n          /**\n     * Invokes callback on every linked (adjacent) node to the given one.\n     *\n     * @param nodeId Identifier of the requested node.\n     * @param {Function(node, link)} callback Function to be called on all linked nodes.\n     *   The function is passed two parameters: adjacent node and link object itself.\n     * @param oriented if true graph treated as oriented.\n     */\n          forEachLinkedNode,\n\n          /**\n     * Enumerates all links in the graph\n     *\n     * @param {Function(link)} callback Function to be called on all links in the graph.\n     *   The function is passed one parameter: graph's link object.\n     *\n     * Link object contains at least the following fields:\n     *  fromId - node id where link starts;\n     *  toId - node id where link ends,\n     *  data - additional data passed to graph.addLink() method.\n     */\n          forEachLink,\n\n          /**\n     * Suspend all notifications about graph changes until\n     * endUpdate is called.\n     */\n          beginUpdate: enterModification,\n\n          /**\n     * Resumes all notifications about graph changes and fires\n     * graph 'changed' event in case there are any pending changes.\n     */\n          endUpdate: exitModification,\n\n          /**\n     * Removes all nodes and links from the graph.\n     */\n          clear,\n\n          /**\n     * Detects whether there is a link between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     * NOTE: this function is synonim for getLink()\n     *\n     * @returns link if there is one. null otherwise.\n     */\n          hasLink: getLink,\n\n          /**\n     * Detects whether there is a node with given id\n     *\n     * Operation complexity is O(1)\n     * NOTE: this function is synonim for getNode()\n     *\n     * @returns node if there is one; Falsy value otherwise.\n     */\n          hasNode: getNode,\n\n          /**\n     * Gets an edge between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     *\n     * @param {string} fromId link start identifier\n     * @param {string} toId link end identifier\n     *\n     * @returns link if there is one. null otherwise.\n     */\n          getLink,\n        };\n\n        // this will add `on()` and `fire()` methods.\n        eventify(graphPart);\n\n        monitorSubscribers();\n\n        return graphPart;\n\n        function monitorSubscribers() {\n          const realOn = graphPart.on;\n\n          // replace real `on` with our temporary on, which will trigger change\n          // modification monitoring:\n          graphPart.on = on;\n\n          function on() {\n          // now it's time to start tracking stuff:\n            graphPart.beginUpdate = enterModification = enterModificationReal;\n            graphPart.endUpdate = exitModification = exitModificationReal;\n            recordLinkChange = recordLinkChangeReal;\n            recordNodeChange = recordNodeChangeReal;\n\n            // this will replace current `on` method with real pub/sub from `eventify`.\n            graphPart.on = realOn;\n            // delegate to real `on` handler:\n            return realOn.apply(graphPart, arguments);\n          }\n        }\n\n        function recordLinkChangeReal(link, changeType) {\n          changes.push({\n            link,\n            changeType,\n          });\n        }\n\n        function recordNodeChangeReal(node, changeType) {\n          changes.push({\n            node,\n            changeType,\n          });\n        }\n\n        function addNode(nodeId, data) {\n          if (nodeId === undefined) {\n            throw new Error('Invalid node identifier');\n          }\n\n          enterModification();\n\n          let node = getNode(nodeId);\n          if (!node) {\n            node = new Node(nodeId, data);\n            nodesCount++;\n            recordNodeChange(node, 'add');\n          } else {\n            node.data = data;\n            recordNodeChange(node, 'update');\n          }\n\n          nodes[nodeId] = node;\n\n          exitModification();\n          return node;\n        }\n\n        function getNode(nodeId) {\n          return nodes[nodeId];\n        }\n\n        function getNodesWithId(id, hash, type, test) {\n          const foundNodes = [];\n          const addr = id.substring(0, id.indexOf(type));\n          const filteredKeys = Object.keys(nodes).filter(key => addr === key.substring(0, key.indexOf(test)));\n          filteredKeys.forEach((key) => {\n            if (nodes[key].data && nodes[key].data.type === test && nodes[key].data.hash !== hash) {\n              foundNodes.push(nodes[key]);\n            }\n          });\n          return foundNodes;\n        }\n\n        function getNodeCount() {\n          return Object.keys(nodes).length;\n        }\n\n        function getAllNodes() {\n          return nodes;\n        }\n\n        function getAllLinks() {\n          return links;\n        }\n\n        function getAllLinkedNodes(node) {\n\n        }\n\n        function removeNode(nodeId) {\n          const node = getNode(nodeId);\n          if (!node) {\n            return false;\n          }\n          fuckNode = Array.from(node.links);\n          enterModification();\n\n          const prevLinks = node.links;\n          if (prevLinks) {\n            node.links = null;\n            for (let i = 0; i < prevLinks.length; ++i) {\n              removeLink(prevLinks[i]);\n            }\n          }\n\n          delete nodes[nodeId];\n          nodesCount--;\n\n          recordNodeChange(node, 'remove');\n\n          exitModification();\n\n          return true;\n        }\n\n\n        function addLink(fromId, toId, data) {\n          enterModification();\n\n          const fromNode = getNode(fromId) || addNode(fromId);\n          const toNode = getNode(toId) || addNode(toId);\n\n          const link = createLink(fromId, toId, data);\n\n          links.push(link);\n\n          // TODO: this is not cool. On large graphs potentially would consume more memory.\n          addLinkToNode(fromNode, link);\n          if (fromId !== toId) {\n          // make sure we are not duplicating links for self-loops\n            addLinkToNode(toNode, link);\n          }\n\n          recordLinkChange(link, 'add');\n\n          exitModification();\n\n          return link;\n        }\n\n        function createSingleLink(fromId, toId, data) {\n          const linkId = makeLinkId(fromId, toId);\n          return new Link(fromId, toId, data, linkId);\n        }\n\n        function createUniqueLink(fromId, toId, data) {\n        // TODO: Get rid of this method.\n          let linkId = makeLinkId(fromId, toId);\n          const isMultiEdge = multiEdges.hasOwnProperty(linkId);\n          if (isMultiEdge || getLink(fromId, toId)) {\n            if (!isMultiEdge) {\n              multiEdges[linkId] = 0;\n            }\n            const suffix = `@${++multiEdges[linkId]}`;\n            linkId = makeLinkId(fromId + suffix, toId + suffix);\n          }\n\n          return new Link(fromId, toId, data, linkId);\n        }\n\n        function getLinks(nodeId) {\n          const node = getNode(nodeId);\n          return node ? node.links : null;\n        }\n\n        function removeLink(link) {\n          if (!link) {\n            return false;\n          }\n          let idx = indexOfElementInArray(link, links);\n          if (idx < 0) {\n            return false;\n          }\n\n          enterModification();\n\n          links.splice(idx, 1);\n\n          const fromNode = getNode(link.fromId);\n          const toNode = getNode(link.toId);\n\n          if (fromNode) {\n            idx = indexOfElementInArray(link, fromNode.links);\n            if (idx >= 0) {\n              fromNode.links.splice(idx, 1);\n            }\n          }\n\n          if (toNode) {\n            idx = indexOfElementInArray(link, toNode.links);\n            if (idx >= 0) {\n              toNode.links.splice(idx, 1);\n            }\n          }\n\n          recordLinkChange(link, 'remove');\n\n          exitModification();\n\n          return true;\n        }\n\n        function getLink(fromNodeId, toNodeId) {\n        // TODO: Use sorted links to speed this up\n          let node = getNode(fromNodeId),\n            i;\n          if (!node || !node.links) {\n            return null;\n          }\n\n          for (i = 0; i < node.links.length; ++i) {\n            const link = node.links[i];\n            if (link.fromId === fromNodeId && link.toId === toNodeId) {\n              return link;\n            }\n          }\n\n          return null; // no link.\n        }\n\n        function clear() {\n          enterModification();\n          forEachNode((node) => {\n            removeNode(node.id);\n          });\n          exitModification();\n        }\n\n        function forEachLink(callback) {\n          let i,\n            length;\n          if (typeof callback === 'function') {\n            for (i = 0, length = links.length; i < length; ++i) {\n              callback(links[i]);\n            }\n          }\n        }\n\n        function forEachLinkedNode(nodeId, callback, oriented) {\n          const node = getNode(nodeId);\n\n          if (node && node.links && typeof callback === 'function') {\n            if (oriented) {\n              return forEachOrientedLink(node.links, nodeId, callback);\n            }\n            return forEachNonOrientedLink(node.links, nodeId, callback);\n          }\n        }\n\n        function forEachNonOrientedLink(links, nodeId, callback) {\n          let quitFast;\n          for (let i = 0; i < links.length; ++i) {\n            const link = links[i];\n            const linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;\n\n            quitFast = callback(nodes[linkedNodeId], link);\n            if (quitFast) {\n              return true; // Client does not need more iterations. Break now.\n            }\n          }\n        }\n\n        function forEachOrientedLink(links, nodeId, callback) {\n          let quitFast;\n          for (let i = 0; i < links.length; ++i) {\n            const link = links[i];\n            if (link.fromId === nodeId) {\n              quitFast = callback(nodes[link.toId], link);\n              if (quitFast) {\n                return true; // Client does not need more iterations. Break now.\n              }\n            }\n          }\n        }\n\n        // we will not fire anything until users of this library explicitly call `on()`\n        // method.\n        function noop() {}\n\n        // Enter, Exit modification allows bulk graph updates without firing events.\n        function enterModificationReal() {\n          suspendEvents += 1;\n        }\n\n        function exitModificationReal() {\n          suspendEvents -= 1;\n          if (suspendEvents === 0 && changes.length > 0) {\n            graphPart.fire('changed', changes);\n            changes.length = 0;\n          }\n        }\n\n        function createNodeIterator() {\n        // Object.keys iterator is 1.3x faster than `for in` loop.\n        // See `https://github.com/anvaka/ngraph.graph/tree/bench-for-in-vs-obj-keys`\n        // branch for perf test\n          return Object.keys ? objectKeysIterator : forInIterator;\n        }\n\n        function objectKeysIterator(callback) {\n          if (typeof callback !== 'function') {\n            return;\n          }\n\n          const keys = Object.keys(nodes);\n          for (let i = 0; i < keys.length; ++i) {\n            if (callback(nodes[keys[i]])) {\n              return true; // client doesn't want to proceed. Return.\n            }\n          }\n        }\n\n        function forInIterator(callback) {\n          if (typeof callback !== 'function') {\n            return;\n          }\n          let node;\n\n          for (node in nodes) {\n            if (callback(nodes[node])) {\n              return true; // client doesn't want to proceed. Return.\n            }\n          }\n        }\n      }\n\n      // need this for old browsers. Should this be a separate module?\n      function indexOfElementInArray(element, array) {\n        if (!array) return -1;\n\n        if (array.indexOf) {\n          return array.indexOf(element);\n        }\n\n        let len = array.length,\n          i;\n\n        for (i = 0; i < len; i += 1) {\n          if (array[i] === element) {\n            return i;\n          }\n        }\n\n        return -1;\n      }\n\n      /**\n * Internal structure to represent node;\n */\n      function Node(id, data) {\n        this.id = id;\n        this.links = null;\n        this.data = data;\n      }\n\n      function addLinkToNode(node, link) {\n        if (node.links) {\n          node.links.push(link);\n        } else {\n          node.links = [link];\n        }\n      }\n\n      /**\n * Internal structure to represent links;\n */\n      function Link(fromId, toId, data, id) {\n        this.fromId = fromId;\n        this.toId = toId;\n        this.data = data;\n        this.id = id;\n      }\n\n      function hashCode(str) {\n        let hash = 0,\n          i,\n          chr,\n          len;\n        if (str.length == 0) return hash;\n        for (i = 0, len = str.length; i < len; i++) {\n          chr = str.charCodeAt(i);\n          hash = ((hash << 5) - hash) + chr;\n          hash |= 0; // Convert to 32bit integer\n        }\n        return hash;\n      }\n\n      function makeLinkId(fromId, toId) {\n        return `${fromId.toString()}👉 ${toId.toString()}`;\n      }\n    }, { 'ngraph.events': 9 }],\n    17: [function (require, module, exports) {\n      module.exports = merge;\n\n      /**\n * Augments `target` with properties in `options`. Does not override\n * target's properties if they are defined and matches expected type in\n * options\n *\n * @returns {Object} merged object\n */\n      function merge(target, options) {\n        let key;\n        if (!target) { target = {}; }\n        if (options) {\n          for (key in options) {\n            if (options.hasOwnProperty(key)) {\n              let targetHasIt = target.hasOwnProperty(key),\n                optionsValueType = typeof options[key],\n                shouldReplace = !targetHasIt || (typeof target[key] !== optionsValueType);\n\n              if (shouldReplace) {\n                target[key] = options[key];\n              } else if (optionsValueType === 'object') {\n              // go deep, don't care about loops here, we are simple API!:\n                target[key] = merge(target[key], options[key]);\n              }\n            }\n          }\n        }\n\n        return target;\n      }\n    }, {}],\n    18: [function (require, module, exports) {\n      module.exports = {\n        Body,\n        Vector2d,\n        Body3d,\n        Vector3d,\n      };\n\n      function Body(x, y) {\n        this.pos = new Vector2d(x, y);\n        this.prevPos = new Vector2d(x, y);\n        this.force = new Vector2d();\n        this.velocity = new Vector2d();\n        this.mass = 1;\n      }\n\n      Body.prototype.setPosition = function (x, y) {\n        this.prevPos.x = this.pos.x = x;\n        this.prevPos.y = this.pos.y = y;\n      };\n\n      function Vector2d(x, y) {\n        if (x && typeof x !== 'number') {\n        // could be another vector\n          this.x = typeof x.x === 'number' ? x.x : 0;\n          this.y = typeof x.y === 'number' ? x.y : 0;\n        } else {\n          this.x = typeof x === 'number' ? x : 0;\n          this.y = typeof y === 'number' ? y : 0;\n        }\n      }\n\n      Vector2d.prototype.reset = function () {\n        this.x = this.y = 0;\n      };\n\n      function Body3d(x, y, z) {\n        this.pos = new Vector3d(x, y, z);\n        this.prevPos = new Vector3d(x, y, z);\n        this.force = new Vector3d();\n        this.velocity = new Vector3d();\n        this.mass = 1;\n      }\n\n      Body3d.prototype.setPosition = function (x, y, z) {\n        this.prevPos.x = this.pos.x = x;\n        this.prevPos.y = this.pos.y = y;\n        this.prevPos.z = this.pos.z = z;\n      };\n\n      function Vector3d(x, y, z) {\n        if (x && typeof x !== 'number') {\n        // could be another vector\n          this.x = typeof x.x === 'number' ? x.x : 0;\n          this.y = typeof x.y === 'number' ? x.y : 0;\n          this.z = typeof x.z === 'number' ? x.z : 0;\n        } else {\n          this.x = typeof x === 'number' ? x : 0;\n          this.y = typeof y === 'number' ? y : 0;\n          this.z = typeof z === 'number' ? z : 0;\n        }\n      }\n\n      Vector3d.prototype.reset = function () {\n        this.x = this.y = this.z = 0;\n      };\n    }, {}],\n    19: [function (require, module, exports) {\n    /**\n * Manages a simulation of physical forces acting on bodies and springs.\n */\n      module.exports = physicsSimulator;\n\n      function physicsSimulator(settings) {\n        const Spring = require('./lib/spring');\n        const expose = require('ngraph.expose');\n        const merge = require('ngraph.merge');\n        const eventify = require('ngraph.events');\n\n        settings = merge(settings, {\n          /**\n       * Ideal length for links (springs in physical model).\n       */\n          springLength: 30,\n\n          /**\n       * Hook's law coefficient. 1 - solid spring.\n       */\n          springCoeff: 0.0008,\n\n          /**\n       * Coulomb's law coefficient. It's used to repel nodes thus should be negative\n       * if you make it positive nodes start attract each other :).\n       */\n          gravity: -1.2,\n\n          /**\n       * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).\n       * The closer it's to 1 the more nodes algorithm will have to go through.\n       * Setting it to one makes Barnes Hut simulation no different from\n       * brute-force forces calculation (each node is considered).\n       */\n          theta: 0.8,\n\n          /**\n       * Drag force coefficient. Used to slow down system, thus should be less than 1.\n       * The closer it is to 0 the less tight system will be.\n       */\n          dragCoeff: 0.02,\n\n          /**\n       * Default time step (dt) for forces integration\n       */\n          timeStep: 20,\n        });\n\n        // We allow clients to override basic factory methods:\n        const createQuadTree = settings.createQuadTree || require('ngraph.quadtreebh');\n        const createBounds = settings.createBounds || require('./lib/bounds');\n        const createDragForce = settings.createDragForce || require('./lib/dragForce');\n        const createSpringForce = settings.createSpringForce || require('./lib/springForce');\n        const integrate = settings.integrator || require('./lib/eulerIntegrator');\n        const createBody = settings.createBody || require('./lib/createBody');\n\n        let bodies = [], // Bodies in this simulation.\n          springs = [], // Springs in this simulation.\n          quadTree = createQuadTree(settings),\n          bounds = createBounds(bodies, settings),\n          springForce = createSpringForce(settings),\n          dragForce = createDragForce(settings);\n\n        let bboxNeedsUpdate = true;\n        const totalMovement = 0; // how much movement we made on last step\n\n        const publicApi = {\n        /**\n     * Array of bodies, registered with current simulator\n     *\n     * Note: To add new body, use addBody() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n          bodies,\n\n          quadTree,\n\n          /**\n     * Array of springs, registered with current simulator\n     *\n     * Note: To add new spring, use addSpring() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n          springs,\n\n          /**\n     * Returns settings with which current simulator was initialized\n     */\n          settings,\n\n          /**\n     * Performs one step of force simulation.\n     *\n     * @returns {boolean} true if system is considered stable; False otherwise.\n     */\n          step() {\n            accumulateForces();\n\n            const movement = integrate(bodies, settings.timeStep);\n            bounds.update();\n\n            return movement;\n          },\n\n          /**\n     * Adds body to the system\n     *\n     * @param {ngraph.physics.primitives.Body} body physical body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n          addBody(body) {\n            if (!body) {\n              throw new Error('Body is required');\n            }\n            bodies.push(body);\n\n            return body;\n          },\n\n          /**\n     * Adds body to the system at given position\n     *\n     * @param {Object} pos position of a body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n          addBodyAt(pos) {\n            if (!pos) {\n              throw new Error('Body position is required');\n            }\n            const body = createBody(pos);\n            bodies.push(body);\n\n            return body;\n          },\n\n          /**\n     * Removes body from the system\n     *\n     * @param {ngraph.physics.primitives.Body} body to remove\n     *\n     * @returns {Boolean} true if body found and removed. falsy otherwise;\n     */\n          removeBody(body) {\n            if (!body) { return; }\n\n            const idx = bodies.indexOf(body);\n            if (idx < 0) { return; }\n\n            bodies.splice(idx, 1);\n            if (bodies.length === 0) {\n              bounds.reset();\n            }\n            return true;\n          },\n\n          /**\n     * Adds a spring to this simulation.\n     *\n     * @returns {Object} - a handle for a spring. If you want to later remove\n     * spring pass it to removeSpring() method.\n     */\n          addSpring(body1, body2, springLength, springWeight, springCoefficient) {\n            if (!body1 || !body2) {\n              throw new Error('Cannot add null spring to force simulator');\n            }\n\n            if (typeof springLength !== 'number') {\n              springLength = -1; // assume global configuration\n            }\n\n            const spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? springCoefficient : -1, springWeight);\n            springs.push(spring);\n\n            // TODO: could mark simulator as dirty.\n            return spring;\n          },\n\n          /**\n     * Returns amount of movement performed on last step() call\n     */\n          getTotalMovement() {\n            return totalMovement;\n          },\n\n          /**\n     * Removes spring from the system\n     *\n     * @param {Object} spring to remove. Spring is an object returned by addSpring\n     *\n     * @returns {Boolean} true if spring found and removed. falsy otherwise;\n     */\n          removeSpring(spring) {\n            if (!spring) { return; }\n            const idx = springs.indexOf(spring);\n            if (idx > -1) {\n              springs.splice(idx, 1);\n              return true;\n            }\n          },\n\n          getBestNewBodyPosition(neighbors) {\n            return bounds.getBestNewPosition(neighbors);\n          },\n\n          /**\n     * Returns bounding box which covers all bodies\n     */\n          getBBox() {\n            if (bboxNeedsUpdate) {\n              bounds.update();\n              bboxNeedsUpdate = false;\n            }\n            return bounds.box;\n          },\n\n          invalidateBBox() {\n            bboxNeedsUpdate = true;\n          },\n\n          gravity(value) {\n            if (value !== undefined) {\n              settings.gravity = value;\n              quadTree.options({ gravity: value });\n              return this;\n            }\n            return settings.gravity;\n          },\n\n          theta(value) {\n            if (value !== undefined) {\n              settings.theta = value;\n              quadTree.options({ theta: value });\n              return this;\n            }\n            return settings.theta;\n          },\n        };\n\n        // allow settings modification via public API:\n        expose(settings, publicApi);\n\n        eventify(publicApi);\n\n        return publicApi;\n\n        function accumulateForces() {\n        // Accumulate forces acting on bodies.\n          let body,\n            i = bodies.length;\n\n          if (i) {\n          // only add bodies if there the array is not empty:\n            quadTree.insertBodies(bodies); // performance: O(n * log n)\n            while (i--) {\n              body = bodies[i];\n              // If body is pinned there is no point updating its forces - it should\n              // never move:\n              if (!body.isPinned) {\n                body.force.reset();\n\n                quadTree.updateBodyForce(body);\n                dragForce.update(body);\n              }\n            }\n          }\n\n          i = springs.length;\n          while (i--) {\n            springForce.update(springs[i]);\n          }\n        }\n      }\n    }, {\n      './lib/bounds': 20, './lib/createBody': 21, './lib/dragForce': 22, './lib/eulerIntegrator': 23, './lib/spring': 24, './lib/springForce': 25, 'ngraph.events': 9, 'ngraph.expose': 10, 'ngraph.merge': 17, 'ngraph.quadtreebh': 26,\n    }],\n    20: [function (require, module, exports) {\n      module.exports = function (bodies, settings) {\n        const random = require('ngraph.random').random(42);\n        const boundingBox = {\n          x1: 0, y1: 0, x2: 0, y2: 0,\n        };\n\n        return {\n          box: boundingBox,\n\n          update: updateBoundingBox,\n\n          reset() {\n            boundingBox.x1 = boundingBox.y1 = 0;\n            boundingBox.x2 = boundingBox.y2 = 0;\n          },\n\n          getBestNewPosition(neighbors) {\n            const graphRect = boundingBox;\n\n            let baseX = 0,\n              baseY = 0;\n\n            if (neighbors.length) {\n              for (let i = 0; i < neighbors.length; ++i) {\n                baseX += neighbors[i].pos.x;\n                baseY += neighbors[i].pos.y;\n              }\n\n              baseX /= neighbors.length;\n              baseY /= neighbors.length;\n            } else {\n              baseX = (graphRect.x1 + graphRect.x2) / 2;\n              baseY = (graphRect.y1 + graphRect.y2) / 2;\n            }\n\n            const springLength = settings.springLength;\n            return {\n              x: baseX + random.next(springLength) - springLength / 2,\n              y: baseY + random.next(springLength) - springLength / 2,\n            };\n          },\n        };\n\n        function updateBoundingBox() {\n          let i = bodies.length;\n          if (i === 0) { return; } // don't have to wory here.\n\n          let x1 = Number.MAX_VALUE,\n            y1 = Number.MAX_VALUE,\n            x2 = Number.MIN_VALUE,\n            y2 = Number.MIN_VALUE;\n\n          while (i--) {\n          // this is O(n), could it be done faster with quadtree?\n          // how about pinned nodes?\n            const body = bodies[i];\n            if (body.isPinned) {\n              body.pos.x = body.prevPos.x;\n              body.pos.y = body.prevPos.y;\n            } else {\n              body.prevPos.x = body.pos.x;\n              body.prevPos.y = body.pos.y;\n            }\n            if (body.pos.x < x1) {\n              x1 = body.pos.x;\n            }\n            if (body.pos.x > x2) {\n              x2 = body.pos.x;\n            }\n            if (body.pos.y < y1) {\n              y1 = body.pos.y;\n            }\n            if (body.pos.y > y2) {\n              y2 = body.pos.y;\n            }\n          }\n\n          boundingBox.x1 = x1;\n          boundingBox.x2 = x2;\n          boundingBox.y1 = y1;\n          boundingBox.y2 = y2;\n        }\n      };\n    }, { 'ngraph.random': 30 }],\n    21: [function (require, module, exports) {\n      const physics = require('ngraph.physics.primitives');\n\n      module.exports = function (pos) {\n        return new physics.Body(pos);\n      };\n    }, { 'ngraph.physics.primitives': 18 }],\n    22: [function (require, module, exports) {\n    /**\n * Represents drag force, which reduces force value on each step by given\n * coefficient.\n *\n * @param {Object} options for the drag force\n * @param {Number=} options.dragCoeff drag force coefficient. 0.1 by default\n */\n      module.exports = function (options) {\n        let merge = require('ngraph.merge'),\n          expose = require('ngraph.expose');\n\n        options = merge(options, {\n          dragCoeff: 0.02,\n        });\n\n        const api = {\n          update(body) {\n            body.force.x -= options.dragCoeff * body.velocity.x;\n            body.force.y -= options.dragCoeff * body.velocity.y;\n          },\n        };\n\n        // let easy access to dragCoeff:\n        expose(options, api, ['dragCoeff']);\n\n        return api;\n      };\n    }, { 'ngraph.expose': 10, 'ngraph.merge': 17 }],\n    23: [function (require, module, exports) {\n    /**\n * Performs forces integration, using given timestep. Uses Euler method to solve\n * differential equation (http://en.wikipedia.org/wiki/Euler_method ).\n *\n * @returns {Number} squared distance of total position updates.\n */\n\n      module.exports = integrate;\n\n      function integrate(bodies, timeStep) {\n        let dx = 0,\n          tx = 0,\n          dy = 0,\n          ty = 0,\n          i,\n          max = bodies.length;\n\n        if (max === 0) {\n          return 0;\n        }\n\n        for (i = 0; i < max; ++i) {\n          let body = bodies[i],\n            coeff = timeStep / body.mass;\n\n          body.velocity.x += coeff * body.force.x;\n          body.velocity.y += coeff * body.force.y;\n          let vx = body.velocity.x,\n            vy = body.velocity.y,\n            v = Math.sqrt(vx * vx + vy * vy);\n\n          if (v > 1) {\n            body.velocity.x = vx / v;\n            body.velocity.y = vy / v;\n          }\n\n          dx = timeStep * body.velocity.x;\n          dy = timeStep * body.velocity.y;\n\n          body.pos.x += dx;\n          body.pos.y += dy;\n\n          tx += Math.abs(dx); ty += Math.abs(dy);\n        }\n\n        return (tx * tx + ty * ty) / max;\n      }\n    }, {}],\n    24: [function (require, module, exports) {\n      module.exports = Spring;\n\n      /**\n * Represents a physical spring. Spring connects two bodies, has rest length\n * stiffness coefficient and optional weight\n */\n      function Spring(fromBody, toBody, length, coeff, weight) {\n        this.from = fromBody;\n        this.to = toBody;\n        this.length = length;\n        this.coeff = coeff;\n\n        this.weight = typeof weight === 'number' ? weight : 1;\n      }\n    }, {}],\n    25: [function (require, module, exports) {\n    /**\n * Represents spring force, which updates forces acting on two bodies, conntected\n * by a spring.\n *\n * @param {Object} options for the spring force\n * @param {Number=} options.springCoeff spring force coefficient.\n * @param {Number=} options.springLength desired length of a spring at rest.\n */\n      module.exports = function (options) {\n        const merge = require('ngraph.merge');\n        const random = require('ngraph.random').random(42);\n        const expose = require('ngraph.expose');\n\n        options = merge(options, {\n          springCoeff: 0.0002,\n          springLength: 80,\n        });\n\n        const api = {\n        /**\n     * Upsates forces acting on a spring\n     */\n          update(spring) {\n            let body1 = spring.from,\n              body2 = spring.to,\n              length = spring.length < 0 ? options.springLength : spring.length,\n              dx = body2.pos.x - body1.pos.x,\n              dy = body2.pos.y - body1.pos.y,\n              r = Math.sqrt(dx * dx + dy * dy);\n\n            if (r === 0) {\n              dx = (random.nextDouble() - 0.5) / 50;\n              dy = (random.nextDouble() - 0.5) / 50;\n              r = Math.sqrt(dx * dx + dy * dy);\n            }\n\n            const d = r - length;\n            const coeff = ((!spring.coeff || spring.coeff < 0) ? options.springCoeff : spring.coeff) * d / r * spring.weight;\n\n            body1.force.x += coeff * dx;\n            body1.force.y += coeff * dy;\n\n            body2.force.x -= coeff * dx;\n            body2.force.y -= coeff * dy;\n          },\n        };\n\n        expose(options, api, ['springCoeff', 'springLength']);\n        return api;\n      };\n    }, { 'ngraph.expose': 10, 'ngraph.merge': 17, 'ngraph.random': 30 }],\n    26: [function (require, module, exports) {\n    /**\n * This is Barnes Hut simulation algorithm for 2d case. Implementation\n * is highly optimized (avoids recusion and gc pressure)\n *\n * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html\n */\n\n      module.exports = function (options) {\n        options = options || {};\n        options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n        options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n\n        // we require deterministic randomness here\n        let random = require('ngraph.random').random(1984),\n          Node = require('./node'),\n          InsertStack = require('./insertStack'),\n          isSamePosition = require('./isSamePosition');\n\n        let gravity = options.gravity,\n          updateQueue = [],\n          insertStack = new InsertStack(),\n          theta = options.theta,\n\n          nodesCache = [],\n          currentInCache = 0,\n          root = newNode();\n\n        return {\n          insertBodies,\n          /**\n     * Gets root node if its present\n     */\n          getRoot() {\n            return root;\n          },\n          updateBodyForce: update,\n          options(newOptions) {\n            if (newOptions) {\n              if (typeof newOptions.gravity === 'number') {\n                gravity = newOptions.gravity;\n              }\n              if (typeof newOptions.theta === 'number') {\n                theta = newOptions.theta;\n              }\n\n              return this;\n            }\n\n            return {\n              gravity,\n              theta,\n            };\n          },\n        };\n\n        function newNode() {\n        // To avoid pressure on GC we reuse nodes.\n          let node = nodesCache[currentInCache];\n          if (node) {\n            node.quad0 = null;\n            node.quad1 = null;\n            node.quad2 = null;\n            node.quad3 = null;\n            node.body = null;\n            node.mass = node.massX = node.massY = 0;\n            node.left = node.right = node.top = node.bottom = 0;\n          } else {\n            node = new Node();\n            nodesCache[currentInCache] = node;\n          }\n\n          ++currentInCache;\n          return node;\n        }\n\n        function update(sourceBody) {\n          let queue = updateQueue,\n            v,\n            dx,\n            dy,\n            r,\n            fx = 0,\n            fy = 0,\n            queueLength = 1,\n            shiftIdx = 0,\n            pushIdx = 1;\n\n          queue[0] = root;\n\n          while (queueLength) {\n            let node = queue[shiftIdx],\n              body = node.body;\n\n            queueLength -= 1;\n            shiftIdx += 1;\n            const differentBody = (body !== sourceBody);\n            if (body && differentBody) {\n            // If the current node is a leaf node (and it is not source body),\n            // calculate the force exerted by the current node on body, and add this\n            // amount to body's net force.\n              dx = body.pos.x - sourceBody.pos.x;\n              dy = body.pos.y - sourceBody.pos.y;\n              r = Math.sqrt(dx * dx + dy * dy);\n\n              if (r === 0) {\n              // Poor man's protection against zero distance.\n                dx = (random.nextDouble() - 0.5) / 50;\n                dy = (random.nextDouble() - 0.5) / 50;\n                r = Math.sqrt(dx * dx + dy * dy);\n              }\n\n              // This is standard gravition force calculation but we divide\n              // by r^3 to save two operations when normalizing force vector.\n              v = gravity * body.mass * sourceBody.mass / (r * r * r);\n              fx += v * dx;\n              fy += v * dy;\n            } else if (differentBody) {\n            // Otherwise, calculate the ratio s / r,  where s is the width of the region\n            // represented by the internal node, and r is the distance between the body\n            // and the node's center-of-mass\n              dx = node.massX / node.mass - sourceBody.pos.x;\n              dy = node.massY / node.mass - sourceBody.pos.y;\n              r = Math.sqrt(dx * dx + dy * dy);\n\n              if (r === 0) {\n              // Sorry about code duplucation. I don't want to create many functions\n              // right away. Just want to see performance first.\n                dx = (random.nextDouble() - 0.5) / 50;\n                dy = (random.nextDouble() - 0.5) / 50;\n                r = Math.sqrt(dx * dx + dy * dy);\n              }\n              // If s / r < θ, treat this internal node as a single body, and calculate the\n              // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n              if ((node.right - node.left) / r < theta) {\n              // in the if statement above we consider node's width only\n              // because the region was squarified during tree creation.\n              // Thus there is no difference between using width or height.\n                v = gravity * node.mass * sourceBody.mass / (r * r * r);\n                fx += v * dx;\n                fy += v * dy;\n              } else {\n              // Otherwise, run the procedure recursively on each of the current node's children.\n\n              // I intentionally unfolded this loop, to save several CPU cycles.\n                if (node.quad0) {\n                  queue[pushIdx] = node.quad0;\n                  queueLength += 1;\n                  pushIdx += 1;\n                }\n                if (node.quad1) {\n                  queue[pushIdx] = node.quad1;\n                  queueLength += 1;\n                  pushIdx += 1;\n                }\n                if (node.quad2) {\n                  queue[pushIdx] = node.quad2;\n                  queueLength += 1;\n                  pushIdx += 1;\n                }\n                if (node.quad3) {\n                  queue[pushIdx] = node.quad3;\n                  queueLength += 1;\n                  pushIdx += 1;\n                }\n              }\n            }\n          }\n\n          sourceBody.force.x += fx;\n          sourceBody.force.y += fy;\n        }\n\n        function insertBodies(bodies) {\n          let x1 = Number.MAX_VALUE,\n            y1 = Number.MAX_VALUE,\n            x2 = Number.MIN_VALUE,\n            y2 = Number.MIN_VALUE,\n            i,\n            max = bodies.length;\n\n          // To reduce quad tree depth we are looking for exact bounding box of all particles.\n          i = max;\n          while (i--) {\n            const x = bodies[i].pos.x;\n            const y = bodies[i].pos.y;\n            if (x < x1) {\n              x1 = x;\n            }\n            if (x > x2) {\n              x2 = x;\n            }\n            if (y < y1) {\n              y1 = y;\n            }\n            if (y > y2) {\n              y2 = y;\n            }\n          }\n\n          // Squarify the bounds.\n          let dx = x2 - x1,\n            dy = y2 - y1;\n          if (dx > dy) {\n            y2 = y1 + dx;\n          } else {\n            x2 = x1 + dy;\n          }\n\n          currentInCache = 0;\n          root = newNode();\n          root.left = x1;\n          root.right = x2;\n          root.top = y1;\n          root.bottom = y2;\n\n          i = max - 1;\n          if (i >= 0) {\n            root.body = bodies[i];\n          }\n          while (i--) {\n            insert(bodies[i], root);\n          }\n        }\n\n        function insert(newBody) {\n          insertStack.reset();\n          insertStack.push(root, newBody);\n\n          while (!insertStack.isEmpty()) {\n            let stackItem = insertStack.pop(),\n              node = stackItem.node,\n              body = stackItem.body;\n\n            if (!node.body) {\n            // This is internal node. Update the total mass of the node and center-of-mass.\n              const x = body.pos.x;\n              const y = body.pos.y;\n              node.mass += body.mass;\n              node.massX += body.mass * x;\n              node.massY += body.mass * y;\n\n              // Recursively insert the body in the appropriate quadrant.\n              // But first find the appropriate quadrant.\n              let quadIdx = 0, // Assume we are in the 0's quad.\n                left = node.left,\n                right = (node.right + left) / 2,\n                top = node.top,\n                bottom = (node.bottom + top) / 2;\n\n              if (x > right) { // somewhere in the eastern part.\n                quadIdx += 1;\n                left = right;\n                right = node.right;\n              }\n              if (y > bottom) { // and in south.\n                quadIdx += 2;\n                top = bottom;\n                bottom = node.bottom;\n              }\n\n              let child = getChild(node, quadIdx);\n              if (!child) {\n              // The node is internal but this quadrant is not taken. Add\n              // subnode to it.\n                child = newNode();\n                child.left = left;\n                child.top = top;\n                child.right = right;\n                child.bottom = bottom;\n                child.body = body;\n\n                setChild(node, quadIdx, child);\n              } else {\n              // continue searching in this quadrant.\n                insertStack.push(child, body);\n              }\n            } else {\n            // We are trying to add to the leaf node.\n            // We have to convert current leaf into internal node\n            // and continue adding two nodes.\n              const oldBody = node.body;\n              node.body = null; // internal nodes do not cary bodies\n\n              if (isSamePosition(oldBody.pos, body.pos)) {\n              // Prevent infinite subdivision by bumping one node\n              // anywhere in this quadrant\n                let retriesCount = 3;\n                do {\n                  const offset = random.nextDouble();\n                  const dx = (node.right - node.left) * offset;\n                  const dy = (node.bottom - node.top) * offset;\n\n                  oldBody.pos.x = node.left + dx;\n                  oldBody.pos.y = node.top + dy;\n                  retriesCount -= 1;\n                // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n                } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n                if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n                // This is very bad, we ran out of precision.\n                // if we do not return from the method we'll get into\n                // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n                // Next layout iteration should get larger bounding box in the first step and fix this\n                  return;\n                }\n              }\n              // Next iteration should subdivide node further.\n              insertStack.push(node, oldBody);\n              insertStack.push(node, body);\n            }\n          }\n        }\n      };\n\n      function getChild(node, idx) {\n        if (idx === 0) return node.quad0;\n        if (idx === 1) return node.quad1;\n        if (idx === 2) return node.quad2;\n        if (idx === 3) return node.quad3;\n        return null;\n      }\n\n      function setChild(node, idx, child) {\n        if (idx === 0) node.quad0 = child;\n        else if (idx === 1) node.quad1 = child;\n        else if (idx === 2) node.quad2 = child;\n        else if (idx === 3) node.quad3 = child;\n      }\n    }, {\n      './insertStack': 27, './isSamePosition': 28, './node': 29, 'ngraph.random': 30,\n    }],\n    27: [function (require, module, exports) {\n      module.exports = InsertStack;\n\n      /**\n * Our implmentation of QuadTree is non-recursive to avoid GC hit\n * This data structure represent stack of elements\n * which we are trying to insert into quad tree.\n */\n      function InsertStack() {\n        this.stack = [];\n        this.popIdx = 0;\n      }\n\n      InsertStack.prototype = {\n        isEmpty() {\n          return this.popIdx === 0;\n        },\n        push(node, body) {\n          const item = this.stack[this.popIdx];\n          if (!item) {\n            // we are trying to avoid memory pressue: create new element\n            // only when absolutely necessary\n            this.stack[this.popIdx] = new InsertStackElement(node, body);\n          } else {\n            item.node = node;\n            item.body = body;\n          }\n          ++this.popIdx;\n        },\n        pop() {\n          if (this.popIdx > 0) {\n            return this.stack[--this.popIdx];\n          }\n        },\n        reset() {\n          this.popIdx = 0;\n        },\n      };\n\n      function InsertStackElement(node, body) {\n        this.node = node; // QuadTree node\n        this.body = body; // physical body which needs to be inserted to node\n      }\n    }, {}],\n    28: [function (require, module, exports) {\n      module.exports = function isSamePosition(point1, point2) {\n        const dx = Math.abs(point1.x - point2.x);\n        const dy = Math.abs(point1.y - point2.y);\n\n        return (dx < 1e-8 && dy < 1e-8);\n      };\n    }, {}],\n    29: [function (require, module, exports) {\n    /**\n * Internal data structure to represent 2D QuadTree node\n */\n      module.exports = function Node() {\n      // body stored inside this node. In quad tree only leaf nodes (by construction)\n      // contain boides:\n        this.body = null;\n\n        // Child nodes are stored in quads. Each quad is presented by number:\n        // 0 | 1\n        // -----\n        // 2 | 3\n        this.quad0 = null;\n        this.quad1 = null;\n        this.quad2 = null;\n        this.quad3 = null;\n\n        // Total mass of current node\n        this.mass = 0;\n\n        // Center of mass coordinates\n        this.massX = 0;\n        this.massY = 0;\n\n        // bounding box coordinates\n        this.left = 0;\n        this.top = 0;\n        this.bottom = 0;\n        this.right = 0;\n      };\n    }, {}],\n    30: [function (require, module, exports) {\n      module.exports = {\n        random,\n        randomIterator,\n      };\n\n      /**\n * Creates seeded PRNG with two methods:\n *   next() and nextDouble()\n */\n      function random(inputSeed) {\n        let seed = typeof inputSeed === 'number' ? inputSeed : (+new Date());\n        const randomFunc = function () {\n          // Robert Jenkins' 32 bit integer hash function.\n          seed = ((seed + 0x7ed55d16) + (seed << 12)) & 0xffffffff;\n          seed = ((seed ^ 0xc761c23c) ^ (seed >>> 19)) & 0xffffffff;\n          seed = ((seed + 0x165667b1) + (seed << 5)) & 0xffffffff;\n          seed = ((seed + 0xd3a2646c) ^ (seed << 9)) & 0xffffffff;\n          seed = ((seed + 0xfd7046c5) + (seed << 3)) & 0xffffffff;\n          seed = ((seed ^ 0xb55a4f09) ^ (seed >>> 16)) & 0xffffffff;\n          return (seed & 0xfffffff) / 0x10000000;\n        };\n\n        return {\n          /**\n       * Generates random integer number in the range from 0 (inclusive) to maxValue (exclusive)\n       *\n       * @param maxValue Number REQUIRED. Ommitting this number will result in NaN values from PRNG.\n       */\n          next(maxValue) {\n            return Math.floor(randomFunc() * maxValue);\n          },\n\n          /**\n       * Generates random double number in the range from 0 (inclusive) to 1 (exclusive)\n       * This function is the same as Math.random() (except that it could be seeded)\n       */\n          nextDouble() {\n            return randomFunc();\n          },\n        };\n      }\n\n      /*\n * Creates iterator over array, which returns items of array in random order\n * Time complexity is guaranteed to be O(n);\n */\n      function randomIterator(array, customRandom) {\n        const localRandom = customRandom || random();\n        if (typeof localRandom.next !== 'function') {\n          throw new Error('customRandom does not match expected API: next() function is missing');\n        }\n\n        return {\n          forEach(callback) {\n            let i,\n              j,\n              t;\n            for (i = array.length - 1; i > 0; --i) {\n              j = localRandom.next(i + 1); // i inclusive\n              t = array[j];\n              array[j] = array[i];\n              array[i] = t;\n\n              callback(t);\n            }\n\n            if (array.length) {\n              callback(array[0]);\n            }\n          },\n\n          /**\n         * Shuffles array randomly, in place.\n         */\n          shuffle() {\n            let i,\n              j,\n              t;\n            for (i = array.length - 1; i > 0; --i) {\n              j = localRandom.next(i + 1); // i inclusive\n              t = array[j];\n              array[j] = array[i];\n              array[i] = t;\n            }\n\n            return array;\n          },\n        };\n      }\n    }, {}],\n    31: [function (require, module, exports) {\n      module.exports = save;\n\n      function save(graph, customNodeTransform, customLinkTransform) {\n      // Object contains `nodes` and `links` arrays.\n        const result = {\n          nodes: [],\n          links: [],\n        };\n\n        const nodeTransform = customNodeTransform || defaultTransformForNode;\n        const linkTransform = customLinkTransform || defaultTransformForLink;\n\n        graph.forEachNode(saveNode);\n        graph.forEachLink(saveLink);\n\n        return JSON.stringify(result);\n\n        function saveNode(node) {\n        // Each node of the graph is processed to take only required fields\n        // `id` and `data`\n          result.nodes.push(nodeTransform(node));\n        }\n\n        function saveLink(link) {\n        // Each link of the graph is also processed to take `fromId`, `toId` and\n        // `data`\n          result.links.push(linkTransform(link));\n        }\n\n        function defaultTransformForNode(node) {\n          const result = {\n            id: node.id,\n          };\n          // We don't want to store undefined fields when it's not necessary:\n          if (node.data !== undefined) {\n            result.data = node.data;\n          }\n\n          return result;\n        }\n\n        function defaultTransformForLink(link) {\n          const result = {\n            fromId: link.fromId,\n            toId: link.toId,\n          };\n\n          if (link.data !== undefined) {\n            result.data = link.data;\n          }\n\n          return result;\n        }\n      }\n    }, {}],\n    32: [function (require, module, exports) {\n      module.exports = svg;\n\n      svg.compile = require('./lib/compile');\n\n      const compileTemplate = svg.compileTemplate = require('./lib/compile_template');\n\n      const domEvents = require('add-event-listener');\n\n      const svgns = 'http://www.w3.org/2000/svg';\n      const xlinkns = 'http://www.w3.org/1999/xlink';\n\n      function svg(element, attrBag) {\n        const svgElement = augment(element);\n        if (attrBag === undefined) {\n          return svgElement;\n        }\n\n        const attributes = Object.keys(attrBag);\n        for (let i = 0; i < attributes.length; ++i) {\n          const attributeName = attributes[i];\n          const value = attrBag[attributeName];\n          if (attributeName === 'link') {\n            svgElement.link(value);\n          } else {\n            svgElement.attr(attributeName, value);\n          }\n        }\n\n        return svgElement;\n      }\n\n      function augment(element) {\n        let svgElement = element;\n\n        if (typeof element === 'string') {\n          svgElement = window.document.createElementNS(svgns, element);\n        } else if (element.simplesvg) {\n          return element;\n        }\n\n        let compiledTempalte;\n\n        svgElement.simplesvg = true; // this is not good, since we are monkey patching svg\n        svgElement.attr = attr;\n        svgElement.append = append;\n        svgElement.link = link;\n        svgElement.text = text;\n\n        // add easy eventing\n        svgElement.on = on;\n        svgElement.off = off;\n\n        // data binding:\n        svgElement.dataSource = dataSource;\n\n        return svgElement;\n\n        function dataSource(model) {\n          if (!compiledTempalte) compiledTempalte = compileTemplate(svgElement);\n          compiledTempalte.link(model);\n          return svgElement;\n        }\n\n        function on(name, cb, useCapture) {\n          domEvents.addEventListener(svgElement, name, cb, useCapture);\n          return svgElement;\n        }\n\n        function off(name, cb, useCapture) {\n          domEvents.removeEventListener(svgElement, name, cb, useCapture);\n          return svgElement;\n        }\n\n        function append(content) {\n          const child = svg(content);\n          svgElement.appendChild(child);\n\n          return child;\n        }\n\n        function attr(name, value) {\n          if (arguments.length === 2) {\n            if (value !== null) {\n              svgElement.setAttributeNS(null, name, value);\n            } else {\n              svgElement.removeAttributeNS(null, name);\n            }\n\n            return svgElement;\n          }\n\n          return svgElement.getAttributeNS(null, name);\n        }\n\n        function link(target) {\n          if (arguments.length) {\n            svgElement.setAttributeNS(xlinkns, 'xlink:href', target);\n            return svgElement;\n          }\n\n          return svgElement.getAttributeNS(xlinkns, 'xlink:href');\n        }\n\n        function text(textContent) {\n          if (textContent !== undefined) {\n            svgElement.textContent = textContent;\n            return svgElement;\n          }\n          return svgElement.textContent;\n        }\n      }\n    }, { './lib/compile': 33, './lib/compile_template': 34, 'add-event-listener': 2 }],\n    33: [function (require, module, exports) {\n      const parser = require('./domparser.js');\n      const svg = require('../');\n\n      module.exports = compile;\n\n      function compile(svgText) {\n        try {\n          svgText = addNamespaces(svgText);\n          return svg(parser.parseFromString(svgText, 'text/xml').documentElement);\n        } catch (e) {\n          throw e;\n        }\n      }\n\n      function addNamespaces(text) {\n        if (!text) return;\n\n        const namespaces = 'xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\"';\n        const match = text.match(/^<\\w+/);\n        if (match) {\n          const tagLength = match[0].length;\n          return `${text.substr(0, tagLength)} ${namespaces} ${text.substr(tagLength)}`;\n        }\n        throw new Error('Cannot parse input text: invalid xml?');\n      }\n    }, { '../': 32, './domparser.js': 35 }],\n    34: [function (require, module, exports) {\n      module.exports = template;\n\n      const BINDING_EXPR = /{{(.+?)}}/;\n\n      function template(domNode) {\n        const allBindings = Object.create(null);\n        extractAllBindings(domNode, allBindings);\n\n        return {\n          link(model) {\n            Object.keys(allBindings).forEach((key) => {\n              const setter = allBindings[key];\n              setter.forEach(changeModel);\n            });\n\n            function changeModel(setter) {\n              setter(model);\n            }\n          },\n        };\n      }\n\n      function extractAllBindings(domNode, allBindings) {\n        const nodeType = domNode.nodeType;\n        const typeSupported = (nodeType === 1) || (nodeType === 3);\n        if (!typeSupported) return;\n        let i;\n        if (domNode.hasChildNodes()) {\n          const domChildren = domNode.childNodes;\n          for (i = 0; i < domChildren.length; ++i) {\n            extractAllBindings(domChildren[i], allBindings);\n          }\n        }\n\n        if (nodeType === 3) { // text:\n          bindTextContent(domNode, allBindings);\n        }\n\n        if (!domNode.attributes) return; // this might be a text. Need to figure out what to do in that case\n\n        const attrs = domNode.attributes;\n        for (i = 0; i < attrs.length; ++i) {\n          bindDomAttribute(attrs[i], domNode, allBindings);\n        }\n      }\n\n      function bindDomAttribute(domAttribute, element, allBindings) {\n        const value = domAttribute.value;\n        if (!value) return; // unary attribute?\n\n        const modelNameMatch = value.match(BINDING_EXPR);\n        if (!modelNameMatch) return; // does not look like a binding\n\n        const attrName = domAttribute.localName;\n        const modelPropertyName = modelNameMatch[1];\n        const isSimpleValue = modelPropertyName.indexOf('.') < 0;\n\n        if (!isSimpleValue) throw new Error('simplesvg currently does not support nested bindings');\n\n        let propertyBindings = allBindings[modelPropertyName];\n        if (!propertyBindings) {\n          propertyBindings = allBindings[modelPropertyName] = [attributeSetter];\n        } else {\n          propertyBindings.push(attributeSetter);\n        }\n\n        function attributeSetter(model) {\n          element.setAttributeNS(null, attrName, model[modelPropertyName]);\n        }\n      }\n      function bindTextContent(element, allBindings) {\n      // todo reduce duplication\n        const value = element.nodeValue;\n        if (!value) return; // unary attribute?\n\n        const modelNameMatch = value.match(BINDING_EXPR);\n        if (!modelNameMatch) return; // does not look like a binding\n\n        const modelPropertyName = modelNameMatch[1];\n        const isSimpleValue = modelPropertyName.indexOf('.') < 0;\n\n        let propertyBindings = allBindings[modelPropertyName];\n        if (!propertyBindings) {\n          propertyBindings = allBindings[modelPropertyName] = [textSetter];\n        } else {\n          propertyBindings.push(textSetter);\n        }\n\n        function textSetter(model) {\n          element.nodeValue = model[modelPropertyName];\n        }\n      }\n    }, {}],\n    35: [function (require, module, exports) {\n      module.exports = createDomparser();\n\n      function createDomparser() {\n        if (typeof DOMParser === 'undefined') {\n          return {\n            parseFromString: fail,\n          };\n        }\n        return new DOMParser();\n      }\n\n      function fail() {\n        throw new Error('DOMParser is not supported by this platform. Please open issue here https://github.com/anvaka/simplesvg');\n      }\n    }, {}],\n    36: [function (require, module, exports) {\n      const centrality = require('ngraph.centrality');\n\n      module.exports = centralityWrapper;\n\n      function centralityWrapper() {\n      // TODO: This should not be a function\n        return {\n          betweennessCentrality,\n          degreeCentrality,\n        };\n      }\n\n      function betweennessCentrality(g) {\n        const betweenness = centrality.betweenness(g);\n        return toVivaGraphCentralityFormat(betweenness);\n      }\n\n      function degreeCentrality(g, kind) {\n        const degree = centrality.degree(g, kind);\n        return toVivaGraphCentralityFormat(degree);\n      }\n\n      function toVivaGraphCentralityFormat(centrality) {\n        return Object.keys(centrality).sort(byValue).map(toKeyValue);\n\n        function byValue(x, y) {\n          return centrality[y] - centrality[x];\n        }\n\n        function toKeyValue(key) {\n          return {\n            key,\n            value: centrality[key],\n          };\n        }\n      }\n    }, { 'ngraph.centrality': 4 }],\n    37: [function (require, module, exports) {\n    /**\n * @fileOverview Contains collection of primitive operations under graph.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n      module.exports = operations;\n\n      function operations() {\n        return {\n        /**\n         * Gets graph density, which is a ratio of actual number of edges to maximum\n         * number of edges. I.e. graph density 1 means all nodes are connected with each other with an edge.\n         * Density 0 - graph has no edges. Runtime: O(1)\n         *\n         * @param graph represents oriented graph structure.\n         * @param directed (optional boolean) represents if the graph should be treated as a directed graph.\n         *\n         * @returns density of the graph if graph has nodes. NaN otherwise. Returns density for undirected graph by default but returns density for directed graph if a boolean 'true' is passed along with the graph.\n         */\n          density(graph, directed) {\n            const nodes = graph.getNodesCount();\n            if (nodes === 0) {\n              return NaN;\n            }\n            if (directed) {\n              return graph.getLinksCount() / (nodes * (nodes - 1));\n            }\n            return 2 * graph.getLinksCount() / (nodes * (nodes - 1));\n          },\n        };\n      }\n    }, {}],\n    38: [function (require, module, exports) {\n    /**\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\n      module.exports = domInputManager;\n\n      const dragndrop = require('./dragndrop.js');\n\n      function domInputManager(graph, graphics) {\n        const nodeEvents = {};\n        return {\n        /**\n     * Called by renderer to listen to drag-n-drop events from node. E.g. for SVG\n     * graphics we may listen to DOM events, whereas for WebGL the graphics\n     * should provide custom eventing mechanism.\n     *\n     * @param node - to be monitored.\n     * @param handlers - object with set of three callbacks:\n     *   onStart: function(),\n     *   onDrag: function(e, offset),\n     *   onStop: function()\n     */\n          bindDragNDrop,\n        };\n\n        function bindDragNDrop(node, handlers) {\n          let events;\n          if (handlers) {\n            const nodeUI = graphics.getNodeUI(node.id);\n            events = dragndrop(nodeUI);\n            if (typeof handlers.onStart === 'function') {\n              events.onStart(handlers.onStart);\n            }\n            if (typeof handlers.onDrag === 'function') {\n              events.onDrag(handlers.onDrag);\n            }\n            if (typeof handlers.onStop === 'function') {\n              events.onStop(handlers.onStop);\n            }\n\n            nodeEvents[node.id] = events;\n          } else if ((events = nodeEvents[node.id])) {\n            events.release();\n            delete nodeEvents[node.id];\n          }\n        }\n      }\n    }, { './dragndrop.js': 39 }],\n    39: [function (require, module, exports) {\n    /**\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\n      module.exports = dragndrop;\n\n      const documentEvents = require('../Utils/documentEvents.js');\n      const browserInfo = require('../Utils/browserInfo.js');\n      const findElementPosition = require('../Utils/findElementPosition.js');\n\n      // TODO: Move to input namespace\n      // TODO: Methods should be extracted into the prototype. This class\n      // does not need to consume so much memory for every tracked element\n      function dragndrop(element) {\n        var start,\n          drag,\n          end,\n          scroll,\n          prevSelectStart,\n          prevDragStart,\n\n          startX = 0,\n          startY = 0,\n          dragObject,\n          touchInProgress = false,\n          pinchZoomLength = 0,\n\n          getMousePos = function (e) {\n            let posx = 0,\n              posy = 0;\n\n            e = e || window.event;\n\n            if (e.pageX || e.pageY) {\n              posx = e.pageX;\n              posy = e.pageY;\n            } else if (e.clientX || e.clientY) {\n              posx = e.clientX + window.document.body.scrollLeft + window.document.documentElement.scrollLeft;\n              posy = e.clientY + window.document.body.scrollTop + window.document.documentElement.scrollTop;\n            }\n\n            return [posx, posy];\n          },\n\n          move = function (e, clientX, clientY) {\n            if (drag) {\n              drag(e, { x: clientX - startX, y: clientY - startY });\n            }\n\n            startX = clientX;\n            startY = clientY;\n          },\n\n          stopPropagation = function (e) {\n            if (e.stopPropagation) { e.stopPropagation(); } else { e.cancelBubble = true; }\n          },\n          preventDefault = function (e) {\n            if (e.preventDefault) { e.preventDefault(); }\n          },\n\n          handleDisabledEvent = function (e) {\n            stopPropagation(e);\n            return false;\n          },\n\n          handleMouseMove = function (e) {\n            e = e || window.event;\n\n            move(e, e.clientX, e.clientY);\n          },\n\n          handleMouseDown = function (e) {\n            e = e || window.event;\n            if (touchInProgress) {\n            // modern browsers will fire mousedown for touch events too\n            // we do not want this, since touch is handled separately.\n              stopPropagation(e);\n              return false;\n            }\n            // for IE, left click == 1\n            // for Firefox, left click == 0\n            const isLeftButton = ((e.button === 1 && window.event !== null) || e.button === 0);\n\n            if (isLeftButton) {\n              startX = e.clientX;\n              startY = e.clientY;\n\n              // TODO: bump zIndex?\n              dragObject = e.target || e.srcElement;\n\n              if (start) { start(e, { x: startX, y: startY }); }\n\n              documentEvents.on('mousemove', handleMouseMove);\n              documentEvents.on('mouseup', handleMouseUp);\n\n\n              stopPropagation(e);\n              // TODO: What if event already there? Not bullet proof:\n              prevSelectStart = window.document.onselectstart;\n              prevDragStart = window.document.ondragstart;\n\n              window.document.onselectstart = handleDisabledEvent;\n              dragObject.ondragstart = handleDisabledEvent;\n\n              // prevent text selection (except IE)\n              return false;\n            }\n          },\n\n          handleMouseUp = function (e) {\n            e = e || window.event;\n\n            documentEvents.off('mousemove', handleMouseMove);\n            documentEvents.off('mouseup', handleMouseUp);\n\n            window.document.onselectstart = prevSelectStart;\n            dragObject.ondragstart = prevDragStart;\n            dragObject = null;\n            if (end) { end(e); }\n          },\n\n          handleMouseWheel = function (e) {\n            if (typeof scroll !== 'function') {\n              return;\n            }\n\n            e = e || window.event;\n            if (e.preventDefault) {\n              e.preventDefault();\n            }\n\n            e.returnValue = false;\n            let delta,\n              mousePos = getMousePos(e),\n              elementOffset = findElementPosition(element),\n              relMousePos = {\n                x: mousePos[0] - elementOffset[0],\n                y: mousePos[1] - elementOffset[1],\n              };\n\n            if (e.wheelDelta) {\n              delta = e.wheelDelta / 360; // Chrome/Safari\n            } else {\n              delta = e.detail / -9; // Mozilla\n            }\n\n            scroll(e, delta, relMousePos);\n          },\n\n          updateScrollEvents = function (scrollCallback) {\n            if (!scroll && scrollCallback) {\n            // client is interested in scrolling. Start listening to events:\n              if (browserInfo.browser === 'webkit') {\n                element.addEventListener('mousewheel', handleMouseWheel, false); // Chrome/Safari\n              } else {\n                element.addEventListener('DOMMouseScroll', handleMouseWheel, false); // Others\n              }\n            } else if (scroll && !scrollCallback) {\n              if (browserInfo.browser === 'webkit') {\n                element.removeEventListener('mousewheel', handleMouseWheel, false); // Chrome/Safari\n              } else {\n                element.removeEventListener('DOMMouseScroll', handleMouseWheel, false); // Others\n              }\n            }\n\n            scroll = scrollCallback;\n          },\n\n          getPinchZoomLength = function (finger1, finger2) {\n            return (finger1.clientX - finger2.clientX) * (finger1.clientX - finger2.clientX) +\n                   (finger1.clientY - finger2.clientY) * (finger1.clientY - finger2.clientY);\n          },\n\n          handleTouchMove = function (e) {\n            if (e.touches.length === 1) {\n              stopPropagation(e);\n\n              const touch = e.touches[0];\n              move(e, touch.clientX, touch.clientY);\n            } else if (e.touches.length === 2) {\n            // it's a zoom:\n              const currentPinchLength = getPinchZoomLength(e.touches[0], e.touches[1]);\n              let delta = 0;\n              if (currentPinchLength < pinchZoomLength) {\n                delta = -1;\n              } else if (currentPinchLength > pinchZoomLength) {\n                delta = 1;\n              }\n              scroll(e, delta, { x: e.touches[0].clientX, y: e.touches[0].clientY });\n              pinchZoomLength = currentPinchLength;\n              stopPropagation(e);\n              preventDefault(e);\n            }\n          },\n\n          handleTouchEnd = function (e) {\n            touchInProgress = false;\n            documentEvents.off('touchmove', handleTouchMove);\n            documentEvents.off('touchend', handleTouchEnd);\n            documentEvents.off('touchcancel', handleTouchEnd);\n            dragObject = null;\n            if (end) { end(e); }\n          },\n\n          handleSignleFingerTouch = function (e, touch) {\n            stopPropagation(e);\n            preventDefault(e);\n\n            startX = touch.clientX;\n            startY = touch.clientY;\n\n            dragObject = e.target || e.srcElement;\n\n            if (start) { start(e, { x: startX, y: startY }); }\n            // TODO: can I enter into the state when touch is in progress\n            // but it's still a single finger touch?\n            if (!touchInProgress) {\n              touchInProgress = true;\n              documentEvents.on('touchmove', handleTouchMove);\n              documentEvents.on('touchend', handleTouchEnd);\n              documentEvents.on('touchcancel', handleTouchEnd);\n            }\n          },\n\n          handleTouchStart = function (e) {\n            if (e.touches.length === 1) {\n              return handleSignleFingerTouch(e, e.touches[0]);\n            } else if (e.touches.length === 2) {\n            // handleTouchMove() will care about pinch zoom.\n              stopPropagation(e);\n              preventDefault(e);\n\n              pinchZoomLength = getPinchZoomLength(e.touches[0], e.touches[1]);\n            }\n          // don't care about the rest.\n          };\n\n\n        element.addEventListener('mousedown', handleMouseDown);\n        element.addEventListener('touchstart', handleTouchStart);\n\n        return {\n          onStart(callback) {\n            start = callback;\n            return this;\n          },\n\n          onDrag(callback) {\n            drag = callback;\n            return this;\n          },\n\n          onStop(callback) {\n            end = callback;\n            return this;\n          },\n\n          /**\n         * Occurs when mouse wheel event happens. callback = function(e, scrollDelta, scrollPoint);\n         */\n          onScroll(callback) {\n            updateScrollEvents(callback);\n            return this;\n          },\n\n          release() {\n            // TODO: could be unsafe. We might wanna release dragObject, etc.\n            element.removeEventListener('mousedown', handleMouseDown);\n            element.removeEventListener('touchstart', handleTouchStart);\n\n            documentEvents.off('mousemove', handleMouseMove);\n            documentEvents.off('mouseup', handleMouseUp);\n            documentEvents.off('touchmove', handleTouchMove);\n            documentEvents.off('touchend', handleTouchEnd);\n            documentEvents.off('touchcancel', handleTouchEnd);\n\n            updateScrollEvents(null);\n          },\n        };\n      }\n    }, { '../Utils/browserInfo.js': 43, '../Utils/documentEvents.js': 44, '../Utils/findElementPosition.js': 45 }],\n    40: [function (require, module, exports) {\n    /**\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\n      module.exports = webglInputManager;\n\n      const createInputEvents = require('../WebGL/webglInputEvents.js');\n\n      function webglInputManager(graph, graphics) {\n        let inputEvents = createInputEvents(graphics),\n          draggedNode = null,\n          internalHandlers = {},\n          pos = { x: 0, y: 0 };\n\n        inputEvents.mouseDown((node, e) => {\n          draggedNode = node;\n          pos.x = e.clientX;\n          pos.y = e.clientY;\n\n          inputEvents.mouseCapture(draggedNode);\n\n          const handlers = internalHandlers[node.id];\n          if (handlers && handlers.onStart) {\n            handlers.onStart(e, pos);\n          }\n\n          return true;\n        }).mouseUp((node) => {\n          inputEvents.releaseMouseCapture(draggedNode);\n\n          draggedNode = null;\n          const handlers = internalHandlers[node.id];\n          if (handlers && handlers.onStop) {\n            handlers.onStop();\n          }\n          return true;\n        }).mouseMove((node, e) => {\n          if (draggedNode) {\n            const handlers = internalHandlers[draggedNode.id];\n            if (handlers && handlers.onDrag) {\n              handlers.onDrag(e, { x: e.clientX - pos.x, y: e.clientY - pos.y });\n            }\n\n            pos.x = e.clientX;\n            pos.y = e.clientY;\n            return true;\n          }\n        });\n\n        return {\n        /**\n         * Called by renderer to listen to drag-n-drop events from node. E.g. for SVG\n         * graphics we may listen to DOM events, whereas for WebGL we graphics\n         * should provide custom eventing mechanism.\n         *\n         * @param node - to be monitored.\n         * @param handlers - object with set of three callbacks:\n         *   onStart: function(),\n         *   onDrag: function(e, offset),\n         *   onStop: function()\n         */\n          bindDragNDrop(node, handlers) {\n            internalHandlers[node.id] = handlers;\n            if (!handlers) {\n              delete internalHandlers[node.id];\n            }\n          },\n        };\n      }\n    }, { '../WebGL/webglInputEvents.js': 61 }],\n    41: [function (require, module, exports) {\n      module.exports = constant;\n\n      const merge = require('ngraph.merge');\n      const random = require('ngraph.random').random;\n      const Rect = require('../Utils/rect.js');\n\n      /**\n * Does not really perform any layouting algorithm but is compliant\n * with renderer interface. Allowing clients to provide specific positioning\n * callback and get static layout of the graph\n *\n * @param {Viva.Graph.graph} graph to layout\n * @param {Object} userSettings\n */\n      function constant(graph, userSettings) {\n        userSettings = merge(userSettings, {\n          maxX: 1024,\n          maxY: 1024,\n          seed: 'Deterministic randomness made me do this',\n        });\n        // This class simply follows API, it does not use some of the arguments:\n        /* jshint unused: false */\n        let rand = random(userSettings.seed),\n          graphRect = new Rect(Number.MAX_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MIN_VALUE),\n          layoutLinks = {},\n\n          placeNodeCallback = function (node) {\n            return {\n              x: rand.next(userSettings.maxX),\n              y: rand.next(userSettings.maxY),\n            };\n          },\n\n          updateGraphRect = function (position, graphRect) {\n            if (position.x < graphRect.x1) { graphRect.x1 = position.x; }\n            if (position.x > graphRect.x2) { graphRect.x2 = position.x; }\n            if (position.y < graphRect.y1) { graphRect.y1 = position.y; }\n            if (position.y > graphRect.y2) { graphRect.y2 = position.y; }\n          },\n\n          layoutNodes = typeof Object.create === 'function' ? Object.create(null) : {},\n\n          ensureNodeInitialized = function (node) {\n            layoutNodes[node.id] = placeNodeCallback(node);\n            updateGraphRect(layoutNodes[node.id], graphRect);\n          },\n\n          updateNodePositions = function () {\n            if (graph.getNodesCount() === 0) { return; }\n\n            graphRect.x1 = Number.MAX_VALUE;\n            graphRect.y1 = Number.MAX_VALUE;\n            graphRect.x2 = Number.MIN_VALUE;\n            graphRect.y2 = Number.MIN_VALUE;\n\n            graph.forEachNode(ensureNodeInitialized);\n          },\n\n          ensureLinkInitialized = function (link) {\n            layoutLinks[link.id] = link;\n          },\n\n          onGraphChanged = function (changes) {\n            for (let i = 0; i < changes.length; ++i) {\n              const change = changes[i];\n              if (change.node) {\n                if (change.changeType === 'add') {\n                  ensureNodeInitialized(change.node);\n                } else {\n                  delete layoutNodes[change.node.id];\n                }\n              } if (change.link) {\n                if (change.changeType === 'add') {\n                  ensureLinkInitialized(change.link);\n                } else {\n                  delete layoutLinks[change.link.id];\n                }\n              }\n            }\n          };\n\n        graph.forEachNode(ensureNodeInitialized);\n        graph.forEachLink(ensureLinkInitialized);\n        graph.on('changed', onGraphChanged);\n\n        return {\n        /**\n         * Attempts to layout graph within given number of iterations.\n         *\n         * @param {integer} [iterationsCount] number of algorithm's iterations.\n         *  The constant layout ignores this parameter.\n         */\n          run(iterationsCount) {\n            this.step();\n          },\n\n          /**\n         * One step of layout algorithm.\n         */\n          step() {\n            updateNodePositions();\n\n            return true; // no need to continue.\n          },\n\n          /**\n         * Returns rectangle structure {x1, y1, x2, y2}, which represents\n         * current space occupied by graph.\n         */\n          getGraphRect() {\n            return graphRect;\n          },\n\n          /**\n         * Request to release all resources\n         */\n          dispose() {\n            graph.off('change', onGraphChanged);\n          },\n\n          /*\n         * Checks whether given node is pinned; all nodes in this layout are pinned.\n         */\n          isNodePinned(node) {\n            return true;\n          },\n\n          /*\n         * Requests layout algorithm to pin/unpin node to its current position\n         * Pinned nodes should not be affected by layout algorithm and always\n         * remain at their position\n         */\n          pinNode(node, isPinned) {\n            // noop\n          },\n\n          /*\n         * Gets position of a node by its id. If node was not seen by this\n         * layout algorithm undefined value is returned;\n         */\n          getNodePosition,\n\n          /**\n         * Returns {from, to} position of a link.\n         */\n          getLinkPosition(linkId) {\n            const link = layoutLinks[linkId];\n            return {\n              from: getNodePosition(link.fromId),\n              to: getNodePosition(link.toId),\n            };\n          },\n\n          /**\n         * Sets position of a node to a given coordinates\n         */\n          setNodePosition(nodeId, x, y) {\n            const pos = layoutNodes[nodeId];\n            if (pos) {\n              pos.x = x;\n              pos.y = y;\n            }\n          },\n\n          // Layout specific methods:\n\n          /**\n         * Based on argument either update default node placement callback or\n         * attempts to place given node using current placement callback.\n         * Setting new node callback triggers position update for all nodes.\n         *\n         * @param {Object} newPlaceNodeCallbackOrNode - if it is a function then\n         * default node placement callback is replaced with new one. Node placement\n         * callback has a form of function (node) {}, and is expected to return an\n         * object with x and y properties set to numbers.\n         *\n         * Otherwise if it's not a function the argument is treated as graph node\n         * and current node placement callback will be used to place it.\n         */\n          placeNode(newPlaceNodeCallbackOrNode) {\n            if (typeof newPlaceNodeCallbackOrNode === 'function') {\n              placeNodeCallback = newPlaceNodeCallbackOrNode;\n              updateNodePositions();\n              return this;\n            }\n\n            // it is not a request to update placeNodeCallback, trying to place\n            // a node using current callback:\n            return placeNodeCallback(newPlaceNodeCallbackOrNode);\n          },\n\n        };\n\n        function getNodePosition(nodeId) {\n          return layoutNodes[nodeId];\n        }\n      }\n    }, { '../Utils/rect.js': 49, 'ngraph.merge': 17, 'ngraph.random': 30 }],\n    42: [function (require, module, exports) {\n    /**\n * This module provides compatibility layer with 0.6.x library. It will be\n * removed in the next version\n */\n\n      const events = require('ngraph.events');\n\n      module.exports = backwardCompatibleEvents;\n\n      function backwardCompatibleEvents(g) {\n        console.log('This method is deprecated. Please use Viva.events() instead');\n\n        if (!g) {\n          return g;\n        }\n\n        const eventsDefined = (g.on !== undefined) ||\n    (g.off !== undefined) ||\n    (g.fire !== undefined);\n\n        if (eventsDefined) {\n        // events already defined, ignore\n          return {\n            extend() {\n              return g;\n            },\n            on: g.on,\n            stop: g.off,\n          };\n        }\n\n        return {\n          extend,\n          on: g.on,\n          stop: g.off,\n        };\n\n        function extend() {\n          const backwardCompatible = events(g);\n          backwardCompatible.addEventListener = backwardCompatible.on;\n          return backwardCompatible;\n        }\n      }\n    }, { 'ngraph.events': 9 }],\n    43: [function (require, module, exports) {\n      module.exports = browserInfo();\n\n      function browserInfo() {\n        if (typeof window === 'undefined' || !window.hasOwnProperty('navigator')) {\n          return {\n            browser: '',\n            version: '0',\n          };\n        }\n\n        let ua = window.navigator.userAgent.toLowerCase(),\n          // Useragent RegExp\n          rwebkit = /(webkit)[ \\/]([\\w.]+)/,\n          ropera = /(opera)(?:.*version)?[ \\/]([\\w.]+)/,\n          rmsie = /(msie) ([\\w.]+)/,\n          rmozilla = /(mozilla)(?:.*? rv:([\\w.]+))?/,\n          match = rwebkit.exec(ua) ||\n    ropera.exec(ua) ||\n    rmsie.exec(ua) ||\n    (ua.indexOf('compatible') < 0 && rmozilla.exec(ua)) ||\n    [];\n\n        return {\n          browser: match[1] || '',\n          version: match[2] || '0',\n        };\n      }\n    }, {}],\n    44: [function (require, module, exports) {\n      const nullEvents = require('./nullEvents.js');\n\n      module.exports = createDocumentEvents();\n\n      function createDocumentEvents() {\n        if (typeof document === undefined) {\n          return nullEvents;\n        }\n\n        return {\n          on,\n          off,\n        };\n      }\n\n      function on(eventName, handler) {\n        document.addEventListener(eventName, handler);\n      }\n\n      function off(eventName, handler) {\n        document.removeEventListener(eventName, handler);\n      }\n    }, { './nullEvents.js': 48 }],\n    45: [function (require, module, exports) {\n    /**\n * Finds the absolute position of an element on a page\n */\n      module.exports = findElementPosition;\n\n      function findElementPosition(obj) {\n        let curleft = 0,\n          curtop = 0;\n        if (obj.offsetParent) {\n          do {\n            curleft += obj.offsetLeft;\n            curtop += obj.offsetTop;\n          } while ((obj = obj.offsetParent) !== null);\n        }\n\n        return [curleft, curtop];\n      }\n    }, {}],\n    46: [function (require, module, exports) {\n      module.exports = getDimension;\n\n      function getDimension(container) {\n        if (!container) {\n          throw {\n            message: 'Cannot get dimensions of undefined container',\n          };\n        }\n\n        // TODO: Potential cross browser bug.\n        const width = container.clientWidth;\n        const height = container.clientHeight;\n\n        return {\n          left: 0,\n          top: 0,\n          width,\n          height,\n        };\n      }\n    }, {}],\n    47: [function (require, module, exports) {\n      const intersect = require('gintersect');\n\n      module.exports = intersectRect;\n\n      function intersectRect(left, top, right, bottom, x1, y1, x2, y2) {\n        return intersect(left, top, left, bottom, x1, y1, x2, y2) ||\n    intersect(left, bottom, right, bottom, x1, y1, x2, y2) ||\n    intersect(right, bottom, right, top, x1, y1, x2, y2) ||\n    intersect(right, top, left, top, x1, y1, x2, y2);\n      }\n    }, { gintersect: 3 }],\n    48: [function (require, module, exports) {\n      module.exports = createNullEvents();\n\n      function createNullEvents() {\n        return {\n          on: noop,\n          off: noop,\n          stop: noop,\n        };\n      }\n\n      function noop() { }\n    }, {}],\n    49: [function (require, module, exports) {\n      module.exports = Rect;\n\n      /**\n * Very generic rectangle.\n */\n      function Rect(x1, y1, x2, y2) {\n        this.x1 = x1 || 0;\n        this.y1 = y1 || 0;\n        this.x2 = x2 || 0;\n        this.y2 = y2 || 0;\n      }\n    }, {}],\n    50: [function (require, module, exports) {\n      (function (global) {\n      /**\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\n        module.exports = createTimer();\n\n        function createTimer() {\n          let lastTime = 0,\n            vendors = ['ms', 'moz', 'webkit', 'o'],\n            i,\n            scope;\n\n          if (typeof window !== 'undefined') {\n            scope = window;\n          } else if (typeof global !== 'undefined') {\n            scope = global;\n          } else {\n            scope = {\n              setTimeout: noop,\n              clearTimeout: noop,\n            };\n          }\n\n          for (i = 0; i < vendors.length && !scope.requestAnimationFrame; ++i) {\n            const vendorPrefix = vendors[i];\n            scope.requestAnimationFrame = scope[`${vendorPrefix}RequestAnimationFrame`];\n            scope.cancelAnimationFrame =\n      scope[`${vendorPrefix}CancelAnimationFrame`] || scope[`${vendorPrefix}CancelRequestAnimationFrame`];\n          }\n\n          if (!scope.requestAnimationFrame) {\n            scope.requestAnimationFrame = rafPolyfill;\n          }\n\n          if (!scope.cancelAnimationFrame) {\n            scope.cancelAnimationFrame = cancelRafPolyfill;\n          }\n\n          return timer;\n\n          /**\n   * Timer that fires callback with given interval (in ms) until\n   * callback returns true;\n   */\n          function timer(callback) {\n            let intervalId;\n            startTimer(); // start it right away.\n\n            return {\n            /**\n       * Stops execution of the callback\n       */\n              stop: stopTimer,\n\n              restart,\n            };\n\n            function startTimer() {\n              intervalId = scope.requestAnimationFrame(startTimer);\n              if (!callback()) {\n                stopTimer();\n              }\n            }\n\n            function stopTimer() {\n              scope.cancelAnimationFrame(intervalId);\n              intervalId = 0;\n            }\n\n            function restart() {\n              if (!intervalId) {\n                startTimer();\n              }\n            }\n          }\n\n          function rafPolyfill(callback) {\n            const currTime = new Date().getTime();\n            const timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            const id = scope.setTimeout(() => {\n              callback(currTime + timeToCall);\n            }, timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n          }\n\n          function cancelRafPolyfill(id) {\n            scope.clearTimeout(id);\n          }\n        }\n\n        function noop() {}\n      }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});\n    }, {}],\n    51: [function (require, module, exports) {\n      const nullEvents = require('./nullEvents.js');\n\n      module.exports = createDocumentEvents();\n\n      function createDocumentEvents() {\n        if (typeof window === 'undefined') {\n          return nullEvents;\n        }\n\n        return {\n          on,\n          off,\n        };\n      }\n\n      function on(eventName, handler) {\n        window.addEventListener(eventName, handler);\n      }\n\n      function off(eventName, handler) {\n        window.removeEventListener(eventName, handler);\n      }\n    }, { './nullEvents.js': 48 }],\n    52: [function (require, module, exports) {\n    /**\n * @fileOverview Defines a graph renderer that uses CSS based drawings.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\n      module.exports = renderer;\n\n      const eventify = require('ngraph.events');\n      const forceDirected = require('ngraph.forcelayout');\n      const svgGraphics = require('./svgGraphics.js');\n      const windowEvents = require('../Utils/windowEvents.js');\n      const domInputManager = require('../Input/domInputManager.js');\n      const timer = require('../Utils/timer.js');\n      const getDimension = require('../Utils/getDimensions.js');\n      const dragndrop = require('../Input/dragndrop.js');\n\n      /**\n * This is heart of the rendering. Class accepts graph to be rendered and rendering settings.\n * It monitors graph changes and depicts them accordingly.\n *\n * @param graph - Viva.Graph.graph() object to be rendered.\n * @param settings - rendering settings, composed from the following parts (with their defaults shown):\n *   settings = {\n *     // Represents a module that is capable of displaying graph nodes and links.\n *     // all graphics has to correspond to defined interface and can be later easily\n *     // replaced for specific needs (e.g. adding WebGL should be piece of cake as long\n *     // as WebGL has implemented required interface). See svgGraphics for example.\n *     graphics : Viva.Graph.View.svgGraphics(),\n *\n *     // Where the renderer should draw graph. Container size matters, because\n *     // renderer will attempt center graph to that size. Also graphics modules\n *     // might depend on it.\n *     container : document.body,\n *\n *     // Defines whether graph can respond to use input\n *     interactive: true,\n *\n *     // Layout algorithm to be used. The algorithm is expected to comply with defined\n *     // interface and is expected to be iterative. Renderer will use it then to calculate\n *     // graph's layout. For examples of the interface refer to Viva.Graph.Layout.forceDirected()\n *     layout : Viva.Graph.Layout.forceDirected(),\n *\n *     // Directs renderer to display links. Usually rendering links is the slowest part of this\n *     // library. So if you don't need to display links, consider settings this property to false.\n *     renderLinks : true,\n *\n *     // Number of layout iterations to run before displaying the graph. The bigger you set this number\n *     // the closer to ideal position graph will appear first time. But be careful: for large graphs\n *     // it can freeze the browser.\n *     prerender : 0\n *   }\n */\n      function renderer(graph, settings) {\n      // TODO: This class is getting hard to understand. Consider refactoring.\n      // TODO: I have a technical debt here: fix scaling/recentering! Currently it's a total mess.\n        const FRAME_INTERVAL = 30;\n\n        settings = settings || {};\n\n        let layout = settings.layout,\n          graphics = settings.graphics,\n          container = settings.container,\n          interactive = settings.interactive !== undefined ? settings.interactive : true,\n          inputManager,\n          animationTimer,\n          rendererInitialized = false,\n          updateCenterRequired = true,\n\n          isStable = false,\n          userInteraction = false,\n          isPaused = false,\n\n          transform = {\n            offsetX: 0,\n            offsetY: 0,\n            scale: 1,\n          },\n\n          publicEvents = eventify({}),\n          containerDrag;\n\n        return {\n        /**\n     * Performs rendering of the graph.\n     *\n     * @param iterationsCount if specified renderer will run only given number of iterations\n     * and then stop. Otherwise graph rendering is performed indefinitely.\n     *\n     * Note: if rendering stopped by used started dragging nodes or new nodes were added to the\n     * graph renderer will give run more iterations to reflect changes.\n     */\n          run(iterationsCount) {\n            if (!rendererInitialized) {\n              prepareSettings();\n              prerender();\n\n              initDom();\n              updateCenter();\n              listenToEvents();\n\n              rendererInitialized = true;\n            }\n\n            renderIterations(iterationsCount);\n\n            return this;\n          },\n\n          reset() {\n            graphics.resetScale();\n            updateCenter();\n            transform.scale = 1;\n          },\n\n          pause() {\n            isPaused = true;\n            animationTimer.stop();\n          },\n\n          resume() {\n            isPaused = false;\n            animationTimer.restart();\n          },\n\n          rerender() {\n            renderGraph();\n            return this;\n          },\n\n          zoomOut() {\n            return scale(true);\n          },\n\n          zoomIn() {\n            return scale(false);\n          },\n\n          /**\n     * Returns current transformation matrix.\n     */\n          getTransform() {\n            return transform;\n          },\n\n          /**\n     * Centers renderer at x,y graph's coordinates\n     */\n          moveTo(x, y) {\n            graphics.graphCenterChanged(transform.offsetX - x * transform.scale, transform.offsetY - y * transform.scale);\n            renderGraph();\n          },\n\n          /**\n     * Gets current graphics object\n     */\n          getGraphics() {\n            return graphics;\n          },\n\n          getLayout() {\n            return layout;\n          },\n\n          /**\n     * Removes this renderer and deallocates all resources/timers\n     */\n          dispose() {\n            stopListenToEvents(); // I quit!\n          },\n\n          on(eventName, callback) {\n            publicEvents.on(eventName, callback);\n            return this;\n          },\n\n          off(eventName, callback) {\n            publicEvents.off(eventName, callback);\n            return this;\n          },\n        };\n\n        /**\n   * Checks whether given interaction (node/scroll) is enabled\n   */\n        function isInteractive(interactionName) {\n          if (typeof interactive === 'string') {\n            return interactive.indexOf(interactionName) >= 0;\n          } else if (typeof interactive === 'boolean') {\n            return interactive;\n          }\n          return true; // default setting\n        }\n\n        function prepareSettings() {\n          container = container || window.document.body;\n          layout = layout || forceDirected(graph, {\n            springLength: 80,\n            springCoeff: 0.0002,\n          });\n          graphics = graphics || svgGraphics(graph, {\n            container,\n          });\n\n          if (!settings.hasOwnProperty('renderLinks')) {\n            settings.renderLinks = true;\n          }\n\n          settings.prerender = settings.prerender || 0;\n          inputManager = (graphics.inputManager || domInputManager)(graph, graphics);\n        }\n\n        function renderGraph() {\n          graphics.beginRender();\n\n          // todo: move this check graphics\n          if (settings.renderLinks) {\n            graphics.renderLinks();\n          }\n          graphics.renderNodes();\n          graphics.endRender();\n        }\n\n        function onRenderFrame() {\n          isStable = layout.step() && !userInteraction;\n          renderGraph();\n\n          return !isStable;\n        }\n\n        function renderIterations(iterationsCount) {\n          if (animationTimer) {\n            return;\n          }\n\n          if (iterationsCount !== undefined) {\n            animationTimer = timer(() => {\n              iterationsCount -= 1;\n              if (iterationsCount < 0) {\n                const needMoreFrames = false;\n                return needMoreFrames;\n              }\n\n              return onRenderFrame();\n            }, FRAME_INTERVAL);\n          } else {\n            animationTimer = timer(onRenderFrame, FRAME_INTERVAL);\n          }\n        }\n\n        function resetStable() {\n          if (isPaused) {\n            return;\n          }\n\n          isStable = false;\n          animationTimer.restart();\n        }\n\n        function prerender() {\n        // To get good initial positions for the graph\n        // perform several prerender steps in background.\n          if (typeof settings.prerender === 'number' && settings.prerender > 0) {\n            for (let i = 0; i < settings.prerender; i += 1) {\n              layout.step();\n            }\n          }\n        }\n\n        function updateCenter() {\n          let graphRect = layout.getGraphRect(),\n            containerSize = getDimension(container);\n\n          const cx = (graphRect.x2 + graphRect.x1) / 2;\n          const cy = (graphRect.y2 + graphRect.y1) / 2;\n          transform.offsetX = containerSize.width / 2 - (cx * transform.scale - cx);\n          transform.offsetY = containerSize.height / 2 - (cy * transform.scale - cy);\n          graphics.graphCenterChanged(transform.offsetX, transform.offsetY);\n\n          updateCenterRequired = false;\n        }\n\n        function createNodeUi(node) {\n          const nodePosition = layout.getNodePosition(node.id);\n          graphics.addNode(node, nodePosition);\n        }\n\n        function removeNodeUi(node) {\n          graphics.releaseNode(node);\n        }\n\n        function createLinkUi(link) {\n          const linkPosition = layout.getLinkPosition(link.id);\n          graphics.addLink(link, linkPosition);\n        }\n\n        function removeLinkUi(link) {\n          graphics.releaseLink(link);\n        }\n\n        function listenNodeEvents(node) {\n          if (!isInteractive('node')) {\n            return;\n          }\n\n          let wasPinned = false;\n\n          // TODO: This may not be memory efficient. Consider reusing handlers object.\n          inputManager.bindDragNDrop(node, {\n            onStart() {\n              wasPinned = layout.isNodePinned(node);\n              layout.pinNode(node, true);\n              userInteraction = true;\n              resetStable();\n            },\n            onDrag(e, offset) {\n              const oldPos = layout.getNodePosition(node.id);\n              layout.setNodePosition(\n                node.id,\n                oldPos.x + offset.x / transform.scale,\n                oldPos.y + offset.y / transform.scale,\n              );\n\n              userInteraction = true;\n\n              renderGraph();\n            },\n            onStop() {\n              layout.pinNode(node, wasPinned);\n              userInteraction = false;\n            },\n          });\n        }\n\n        function releaseNodeEvents(node) {\n          inputManager.bindDragNDrop(node, null);\n        }\n\n        function initDom() {\n          graphics.init(container);\n\n          graph.forEachNode(createNodeUi);\n\n          if (settings.renderLinks) {\n            graph.forEachLink(createLinkUi);\n          }\n        }\n\n        function releaseDom() {\n          graphics.release(container);\n        }\n\n        function processNodeChange(change) {\n          const node = change.node;\n\n          if (change.changeType === 'add') {\n            createNodeUi(node);\n            listenNodeEvents(node);\n            if (updateCenterRequired) {\n              updateCenter();\n            }\n          } else if (change.changeType === 'remove') {\n            releaseNodeEvents(node);\n            removeNodeUi(node);\n            if (graph.getNodesCount() === 0) {\n              updateCenterRequired = true; // Next time when node is added - center the graph.\n            }\n          } else if (change.changeType === 'update') {\n            releaseNodeEvents(node);\n            removeNodeUi(node);\n\n            createNodeUi(node);\n            listenNodeEvents(node);\n          }\n        }\n\n        function processLinkChange(change) {\n          const link = change.link;\n          if (change.changeType === 'add') {\n            if (settings.renderLinks) {\n              createLinkUi(link);\n            }\n          } else if (change.changeType === 'remove') {\n            if (settings.renderLinks) {\n              removeLinkUi(link);\n            }\n          } else if (change.changeType === 'update') {\n            throw 'Update type is not implemented. TODO: Implement me!';\n          }\n        }\n\n        function onGraphChanged(changes) {\n          let i,\n            change;\n          for (i = 0; i < changes.length; i += 1) {\n            change = changes[i];\n            if (change.node) {\n              processNodeChange(change);\n            } else if (change.link) {\n              processLinkChange(change);\n            }\n          }\n\n          resetStable();\n        }\n\n        function onWindowResized() {\n          updateCenter();\n          onRenderFrame();\n        }\n\n        function releaseContainerDragManager() {\n          if (containerDrag) {\n            containerDrag.release();\n            containerDrag = null;\n          }\n        }\n\n        function releaseGraphEvents() {\n          graph.off('changed', onGraphChanged);\n        }\n\n        function scale(out, scrollPoint) {\n          if (!scrollPoint) {\n            const containerSize = getDimension(container);\n            scrollPoint = {\n              x: containerSize.width / 2,\n              y: containerSize.height / 2,\n            };\n          }\n          const scaleFactor = Math.pow(1 + 0.4, out ? -0.2 : 0.2);\n          transform.scale = graphics.scale(scaleFactor, scrollPoint);\n\n          renderGraph();\n          publicEvents.fire('scale', transform.scale);\n\n          return transform.scale;\n        }\n\n        function listenToEvents() {\n          windowEvents.on('resize', onWindowResized);\n\n          releaseContainerDragManager();\n          if (isInteractive('drag')) {\n            containerDrag = dragndrop(container);\n            containerDrag.onDrag((e, offset) => {\n              graphics.translateRel(offset.x, offset.y);\n\n              renderGraph();\n              publicEvents.fire('drag', offset);\n            });\n          }\n\n          if (isInteractive('scroll')) {\n            if (!containerDrag) {\n              containerDrag = dragndrop(container);\n            }\n            containerDrag.onScroll((e, scaleOffset, scrollPoint) => {\n              scale(scaleOffset < 0, scrollPoint);\n            });\n          }\n\n          graph.forEachNode(listenNodeEvents);\n\n          releaseGraphEvents();\n          graph.on('changed', onGraphChanged);\n        }\n\n        function stopListenToEvents() {\n          rendererInitialized = false;\n          releaseGraphEvents();\n          releaseContainerDragManager();\n          windowEvents.off('resize', onWindowResized);\n          publicEvents.off();\n          animationTimer.stop();\n\n          graph.forEachLink((link) => {\n            if (settings.renderLinks) {\n              removeLinkUi(link);\n            }\n          });\n\n          graph.forEachNode((node) => {\n            releaseNodeEvents(node);\n            removeNodeUi(node);\n          });\n\n          layout.dispose();\n          releaseDom();\n        }\n      }\n    }, {\n      '../Input/domInputManager.js': 38, '../Input/dragndrop.js': 39, '../Utils/getDimensions.js': 46, '../Utils/timer.js': 50, '../Utils/windowEvents.js': 51, './svgGraphics.js': 53, 'ngraph.events': 9, 'ngraph.forcelayout': 11,\n    }],\n    53: [function (require, module, exports) {\n    /**\n * @fileOverview Defines a graph renderer that uses SVG based drawings.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\n      module.exports = svgGraphics;\n\n      const svg = require('simplesvg');\n      const eventify = require('ngraph.events');\n      const domInputManager = require('../Input/domInputManager.js');\n\n      /**\n * Performs svg-based graph rendering. This module does not perform\n * layout, but only visualizes nodes and edges of the graph.\n */\n      function svgGraphics() {\n        let svgContainer,\n          svgRoot,\n          offsetX = 0,\n          offsetY = 0,\n          initCallback,\n          actualScale = 1,\n          allNodes = {},\n          allLinks = {},\n          /* jshint unused: false */\n          nodeBuilder = function (node) {\n            return svg('rect')\n              .attr('width', 10)\n              .attr('height', 10)\n              .attr('fill', '#00a2e8');\n          },\n\n          nodePositionCallback = function (nodeUI, pos) {\n          // TODO: Remove magic 5. It should be half of the width or height of the node.\n            nodeUI.attr('x', pos.x - 5)\n              .attr('y', pos.y - 5);\n          },\n\n          linkBuilder = function (link) {\n            return svg('line').attr('stroke', '#999');\n          },\n\n          linkPositionCallback = function (linkUI, fromPos, toPos) {\n            linkUI.attr('x1', fromPos.x)\n              .attr('y1', fromPos.y)\n              .attr('x2', toPos.x)\n              .attr('y2', toPos.y);\n          },\n\n          fireRescaled = function (graphics) {\n          // TODO: maybe we shall copy changes?\n            graphics.fire('rescaled');\n          },\n\n          cachedPos = { x: 0, y: 0 },\n          cachedFromPos = { x: 0, y: 0 },\n          cachedToPos = { x: 0, y: 0 },\n\n          updateTransform = function () {\n            if (svgContainer) {\n              const transform = `matrix(${actualScale}, 0, 0,${actualScale},${offsetX},${offsetY})`;\n              svgContainer.attr('transform', transform);\n            }\n          };\n\n        svgRoot = createSvgRoot();\n\n        const graphics = {\n          getNodeUI(nodeId) {\n            return allNodes[nodeId];\n          },\n\n          getLinkUI(linkId) {\n            return allLinks[linkId];\n          },\n\n          /**\n         * Sets the callback that creates node representation.\n         *\n         * @param builderCallback a callback function that accepts graph node\n         * as a parameter and must return an element representing this node.\n         *\n         * @returns If builderCallbackOrNode is a valid callback function, instance of this is returned;\n         * Otherwise undefined value is returned\n         */\n          node(builderCallback) {\n            if (typeof builderCallback !== 'function') {\n              return; // todo: throw? This is not compatible with old versions\n            }\n\n            nodeBuilder = builderCallback;\n\n            return this;\n          },\n\n          /**\n         * Sets the callback that creates link representation\n         *\n         * @param builderCallback a callback function that accepts graph link\n         * as a parameter and must return an element representing this link.\n         *\n         * @returns If builderCallback is a valid callback function, instance of this is returned;\n         * Otherwise undefined value is returned.\n         */\n          link(builderCallback) {\n            if (typeof builderCallback !== 'function') {\n              return; // todo: throw? This is not compatible with old versions\n            }\n\n            linkBuilder = builderCallback;\n            return this;\n          },\n\n          /**\n         * Allows to override default position setter for the node with a new\n         * function. newPlaceCallback(nodeUI, position, node) is function which\n         * is used by updateNodePosition().\n         */\n          placeNode(newPlaceCallback) {\n            nodePositionCallback = newPlaceCallback;\n            return this;\n          },\n\n          placeLink(newPlaceLinkCallback) {\n            linkPositionCallback = newPlaceLinkCallback;\n            return this;\n          },\n\n          /**\n         * Called every before renderer starts rendering.\n         */\n          beginRender() {},\n\n          /**\n         * Called every time when renderer finishes one step of rendering.\n         */\n          endRender() {},\n\n          /**\n         * Sets translate operation that should be applied to all nodes and links.\n         */\n          graphCenterChanged(x, y) {\n            offsetX = x;\n            offsetY = y;\n            updateTransform();\n          },\n\n          /**\n         * Default input manager listens to DOM events to process nodes drag-n-drop\n         */\n          inputManager: domInputManager,\n\n          translateRel(dx, dy) {\n            let p = svgRoot.createSVGPoint(),\n              t = svgContainer.getCTM(),\n              origin = svgRoot.createSVGPoint().matrixTransform(t.inverse());\n\n            p.x = dx;\n            p.y = dy;\n\n            p = p.matrixTransform(t.inverse());\n            p.x = (p.x - origin.x) * t.a;\n            p.y = (p.y - origin.y) * t.d;\n\n            t.e += p.x;\n            t.f += p.y;\n\n            const transform = `matrix(${t.a}, 0, 0,${t.d},${t.e},${t.f})`;\n            svgContainer.attr('transform', transform);\n          },\n\n          scale(scaleFactor, scrollPoint) {\n            let p = svgRoot.createSVGPoint();\n            p.x = scrollPoint.x;\n            p.y = scrollPoint.y;\n\n            p = p.matrixTransform(svgContainer.getCTM().inverse()); // translate to SVG coordinates\n\n            // Compute new scale matrix in current mouse position\n            let k = svgRoot.createSVGMatrix().translate(p.x, p.y).scale(scaleFactor).translate(-p.x, -p.y),\n              t = svgContainer.getCTM().multiply(k);\n\n            actualScale = t.a;\n            offsetX = t.e;\n            offsetY = t.f;\n            const transform = `matrix(${t.a}, 0, 0,${t.d},${t.e},${t.f})`;\n            svgContainer.attr('transform', transform);\n\n            fireRescaled(this);\n            return actualScale;\n          },\n\n          resetScale() {\n            actualScale = 1;\n            const transform = 'matrix(1, 0, 0, 1, 0, 0)';\n            svgContainer.attr('transform', transform);\n            fireRescaled(this);\n            return this;\n          },\n\n          /**\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\n        * provider prepare to render.\n        */\n          init(container) {\n            container.appendChild(svgRoot);\n            updateTransform();\n            // Notify the world if someone waited for update. TODO: should send an event\n            if (typeof initCallback === 'function') {\n              initCallback(svgRoot);\n            }\n          },\n\n          /**\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\n        * provider release occupied resources.\n        */\n          release(container) {\n            if (svgRoot && container) {\n              container.removeChild(svgRoot);\n            }\n          },\n\n          /**\n         * Called by Viva.Graph.View.renderer to let concrete graphic output\n         * provider prepare to render given link of the graph\n         *\n         * @param link - model of a link\n         */\n          addLink(link, pos) {\n            const linkUI = linkBuilder(link);\n            if (!linkUI) { return; }\n            linkUI.position = pos;\n            linkUI.link = link;\n            allLinks[link.id] = linkUI;\n            if (svgContainer.childElementCount > 0) {\n              svgContainer.insertBefore(linkUI, svgContainer.firstChild);\n            } else {\n              svgContainer.appendChild(linkUI);\n            }\n            return linkUI;\n          },\n\n          /**\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\n        * provider remove link from rendering surface.\n        *\n        * @param linkUI visual representation of the link created by link() execution.\n        * */\n          releaseLink(link) {\n            const linkUI = allLinks[link.id];\n            if (linkUI) {\n              svgContainer.removeChild(linkUI);\n              delete allLinks[link.id];\n            }\n          },\n\n          /**\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\n        * provider prepare to render given node of the graph.\n        *\n        * @param nodeUI visual representation of the node created by node() execution.\n        * */\n          addNode(node, pos) {\n            const nodeUI = nodeBuilder(node);\n            if (!nodeUI) {\n              return;\n            }\n            nodeUI.position = pos;\n            nodeUI.node = node;\n            allNodes[node.id] = nodeUI;\n\n            svgContainer.appendChild(nodeUI);\n\n            return nodeUI;\n          },\n\n          /**\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\n        * provider remove node from rendering surface.\n        *\n        * @param node graph's node\n        * */\n          releaseNode(node) {\n            const nodeUI = allNodes[node.id];\n            if (nodeUI) {\n              svgContainer.removeChild(nodeUI);\n              delete allNodes[node.id];\n            }\n          },\n\n          renderNodes() {\n            for (const key in allNodes) {\n              if (allNodes.hasOwnProperty(key)) {\n                const nodeUI = allNodes[key];\n                cachedPos.x = nodeUI.position.x;\n                cachedPos.y = nodeUI.position.y;\n                nodePositionCallback(nodeUI, cachedPos, nodeUI.node);\n              }\n            }\n          },\n\n          renderLinks() {\n            for (const key in allLinks) {\n              if (allLinks.hasOwnProperty(key)) {\n                const linkUI = allLinks[key];\n                cachedFromPos.x = linkUI.position.from.x;\n                cachedFromPos.y = linkUI.position.from.y;\n                cachedToPos.x = linkUI.position.to.x;\n                cachedToPos.y = linkUI.position.to.y;\n                linkPositionCallback(linkUI, cachedFromPos, cachedToPos, linkUI.link);\n              }\n            }\n          },\n\n          /**\n         * Returns root element which hosts graphics.\n         */\n          getGraphicsRoot(callbackWhenReady) {\n            // todo: should fire an event, instead of having this context.\n            if (typeof callbackWhenReady === 'function') {\n              if (svgRoot) {\n                callbackWhenReady(svgRoot);\n              } else {\n                initCallback = callbackWhenReady;\n              }\n            }\n            return svgRoot;\n          },\n          /**\n         * Returns root SVG element.\n         *\n         * Note: This is internal method specific to this renderer\n         */\n          getSvgRoot() {\n            return svgRoot;\n          },\n        };\n\n\n        // Let graphics fire events before we return it to the caller.\n        eventify(graphics);\n\n        return graphics;\n\n        function createSvgRoot() {\n          const svgRoot = svg('svg');\n\n          svgContainer = svg('g')\n            .attr('buffered-rendering', 'dynamic');\n\n          svgRoot.appendChild(svgContainer);\n          return svgRoot;\n        }\n      }\n    }, { '../Input/domInputManager.js': 38, 'ngraph.events': 9, simplesvg: 32 }],\n    54: [function (require, module, exports) {\n    /**\n * @fileOverview Defines a graph renderer that uses WebGL based drawings.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\n      module.exports = webglGraphics;\n\n      const webglInputManager = require('../Input/webglInputManager.js');\n      const webglLinkProgram = require('../WebGL/webglLinkProgram.js');\n      const webglNodeProgram = require('../WebGL/webglNodeProgram.js');\n      const webglSquare = require('../WebGL/webglSquare.js');\n      const webglLine = require('../WebGL/webglLine.js');\n      const eventify = require('ngraph.events');\n      const merge = require('ngraph.merge');\n\n      /**\n * Performs webgl-based graph rendering. This module does not perform\n * layout, but only visualizes nodes and edges of the graph.\n *\n * @param options - to customize graphics  behavior. Currently supported parameter\n *  enableBlending - true by default, allows to use transparency in node/links colors.\n *  preserveDrawingBuffer - false by default, tells webgl to preserve drawing buffer.\n *                    See https://www.khronos.org/registry/webgl/specs/1.0/#5.2\n */\n\n      function webglGraphics(options) {\n        options = merge(options, {\n          enableBlending: true,\n          preserveDrawingBuffer: false,\n          clearColor: false,\n          clearColorValue: {\n            r: 1,\n            g: 1,\n            b: 1,\n            a: 1,\n          },\n        });\n\n        let container,\n          graphicsRoot,\n          gl,\n          width,\n          height,\n          nodesCount = 0,\n          linksCount = 0,\n          transform = [\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1,\n          ],\n          userPlaceNodeCallback,\n          userPlaceLinkCallback,\n          nodes = [],\n          links = [],\n          initCallback,\n\n          allNodes = {},\n          allLinks = {},\n          linkProgram = webglLinkProgram(),\n          nodeProgram = webglNodeProgram(),\n          /* jshint unused: false */\n          nodeUIBuilder = function (node) {\n            return webglSquare(); // Just make a square, using provided gl context (a nodeProgram);\n          },\n\n          linkUIBuilder = function (link) {\n            return webglLine(0xb3b3b3ff);\n          },\n          /* jshint unused: true */\n          updateTransformUniform = function () {\n            linkProgram.updateTransform(transform);\n            nodeProgram.updateTransform(transform);\n          },\n\n          resetScaleInternal = function () {\n            transform = [1, 0, 0, 0,\n              0, 1, 0, 0,\n              0, 0, 1, 0,\n              0, 0, 0, 1];\n          },\n\n          updateSize = function () {\n            if (container && graphicsRoot) {\n              width = graphicsRoot.width = Math.max(container.offsetWidth, 1);\n              height = graphicsRoot.height = Math.max(container.offsetHeight, 1);\n              if (gl) { gl.viewport(0, 0, width, height); }\n              if (linkProgram) { linkProgram.updateSize(width / 2, height / 2); }\n              if (nodeProgram) { nodeProgram.updateSize(width / 2, height / 2); }\n            }\n          },\n\n          fireRescaled = function (graphics) {\n            graphics.fire('rescaled');\n          };\n\n        graphicsRoot = window.document.createElement('canvas');\n\n        const graphics = {\n          getLinkUI(linkId) {\n            return allLinks[linkId];\n          },\n\n          getNodeUI(nodeId) {\n            return allNodes[nodeId];\n          },\n\n          /**\n         * Sets the callback that creates node representation.\n         *\n         * @param builderCallback a callback function that accepts graph node\n         * as a parameter and must return an element representing this node.\n         *\n         * @returns If builderCallbackOrNode is a valid callback function, instance of this is returned;\n         * Otherwise undefined value is returned\n         */\n          node(builderCallback) {\n            if (typeof builderCallback !== 'function') {\n              return; // todo: throw? This is not compatible with old versions\n            }\n\n            nodeUIBuilder = builderCallback;\n\n            return this;\n          },\n\n          /**\n         * Sets the callback that creates link representation\n         *\n         * @param builderCallback a callback function that accepts graph link\n         * as a parameter and must return an element representing this link.\n         *\n         * @returns If builderCallback is a valid callback function, instance of this is returned;\n         * Otherwise undefined value is returned.\n         */\n          link(builderCallback) {\n            if (typeof builderCallback !== 'function') {\n              return; // todo: throw? This is not compatible with old versions\n            }\n\n            linkUIBuilder = builderCallback;\n            return this;\n          },\n\n\n          /**\n         * Allows to override default position setter for the node with a new\n         * function. newPlaceCallback(nodeUI, position) is function which\n         * is used by updateNodePosition().\n         */\n          placeNode(newPlaceCallback) {\n            userPlaceNodeCallback = newPlaceCallback;\n            return this;\n          },\n\n          placeLink(newPlaceLinkCallback) {\n            userPlaceLinkCallback = newPlaceLinkCallback;\n            return this;\n          },\n\n          /**\n         * Custom input manager listens to mouse events to process nodes drag-n-drop inside WebGL canvas\n         */\n          inputManager: webglInputManager,\n\n          /**\n         * Called every time before renderer starts rendering.\n         */\n          beginRender() {\n            // this function could be replaced by this.init,\n            // based on user options.\n          },\n\n          /**\n         * Called every time when renderer finishes one step of rendering.\n         */\n          endRender() {\n            if (linksCount > 0) {\n              linkProgram.render();\n            }\n            if (nodesCount > 0) {\n              nodeProgram.render();\n            }\n          },\n\n          bringLinkToFront(linkUI) {\n            let frontLinkId = linkProgram.getFrontLinkId(),\n              srcLinkId,\n              temp;\n\n            linkProgram.bringToFront(linkUI);\n\n            if (frontLinkId > linkUI.id) {\n              srcLinkId = linkUI.id;\n\n              temp = links[frontLinkId];\n              links[frontLinkId] = links[srcLinkId];\n              links[frontLinkId].id = frontLinkId;\n              links[srcLinkId] = temp;\n              links[srcLinkId].id = srcLinkId;\n            }\n          },\n\n          /**\n         * Sets translate operation that should be applied to all nodes and links.\n         */\n          graphCenterChanged(x, y) {\n            transform[12] = (2 * x / width) - 1;\n            transform[13] = 1 - (2 * y / height);\n            updateTransformUniform();\n          },\n\n          /**\n         * Called by Viva.Graph.View.renderer to let concrete graphic output\n         * provider prepare to render given link of the graph\n         *\n         * @param link - model of a link\n         */\n          addLink(link, boundPosition) {\n            let uiid = linksCount++,\n              ui = linkUIBuilder(link);\n            ui.id = uiid;\n            ui.pos = boundPosition;\n\n            linkProgram.createLink(ui);\n\n            links[uiid] = ui;\n            allLinks[link.id] = ui;\n            return ui;\n          },\n\n          /**\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\n        * provider prepare to render given node of the graph.\n        *\n        * @param nodeUI visual representation of the node created by node() execution.\n        * */\n          addNode(node, boundPosition) {\n            let uiid = nodesCount++,\n              ui = nodeUIBuilder(node);\n\n            ui.id = uiid;\n            ui.position = boundPosition;\n            ui.node = node;\n\n            nodeProgram.createNode(ui);\n\n            nodes[uiid] = ui;\n            allNodes[node.id] = ui;\n            return ui;\n          },\n\n          translateRel(dx, dy) {\n            transform[12] += (2 * transform[0] * dx / width) / transform[0];\n            transform[13] -= (2 * transform[5] * dy / height) / transform[5];\n            updateTransformUniform();\n          },\n\n          scale(scaleFactor, scrollPoint) {\n            // Transform scroll point to clip-space coordinates:\n            let cx = 2 * scrollPoint.x / width - 1,\n              cy = 1 - (2 * scrollPoint.y) / height;\n\n            cx -= transform[12];\n            cy -= transform[13];\n\n            transform[12] += cx * (1 - scaleFactor);\n            transform[13] += cy * (1 - scaleFactor);\n\n            transform[0] *= scaleFactor;\n            transform[5] *= scaleFactor;\n\n            updateTransformUniform();\n            fireRescaled(this);\n\n            return transform[0];\n          },\n\n          resetScale() {\n            resetScaleInternal();\n\n            if (gl) {\n              updateSize();\n              // TODO: what is this?\n              // gl.useProgram(linksProgram);\n              // gl.uniform2f(linksProgram.screenSize, width, height);\n              updateTransformUniform();\n            }\n            return this;\n          },\n\n          /**\n        * Resizes the graphic without resetting the scale.\n        * Useful with viva graph in a dynamic container\n        */\n          updateSize,\n\n          /**\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\n        * provider prepare to render.\n        */\n          init(c) {\n            const contextParameters = {};\n\n            if (options.preserveDrawingBuffer) {\n              contextParameters.preserveDrawingBuffer = true;\n            }\n\n            container = c;\n\n            updateSize();\n            resetScaleInternal();\n            container.appendChild(graphicsRoot);\n\n\n            gl = graphicsRoot.getContext('experimental-webgl', contextParameters);\n            if (!gl) {\n              const msg = \"Could not initialize WebGL. Seems like the browser doesn't support it.\";\n              window.alert(msg);\n              throw msg;\n            }\n            if (options.enableBlending) {\n              gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n              gl.enable(gl.BLEND);\n            }\n            if (options.clearColor) {\n              const color = options.clearColorValue;\n              gl.clearColor(color.r, color.g, color.b, color.a);\n              // TODO: not the best way, really. Should come up with something better\n              // what if we need more updates inside beginRender, like depth buffer?\n              this.beginRender = function () {\n                gl.clear(gl.COLOR_BUFFER_BIT);\n              };\n            }\n\n            linkProgram.load(gl);\n            linkProgram.updateSize(width / 2, height / 2);\n\n            nodeProgram.load(gl);\n            nodeProgram.updateSize(width / 2, height / 2);\n\n            updateTransformUniform();\n\n            // Notify the world if someone waited for update. TODO: should send an event\n            if (typeof initCallback === 'function') {\n              initCallback(graphicsRoot);\n            }\n          },\n\n          /**\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\n        * provider release occupied resources.\n        */\n          release(container) {\n            if (graphicsRoot && container) {\n              container.removeChild(graphicsRoot);\n              // TODO: anything else?\n            }\n          },\n\n          /**\n        * Checks whether webgl is supported by this browser.\n        */\n          isSupported() {\n            let c = window.document.createElement('canvas'),\n              gl = c && c.getContext && c.getContext('experimental-webgl');\n            return gl;\n          },\n\n          /**\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\n        * provider remove link from rendering surface.\n        *\n        * @param linkUI visual representation of the link created by link() execution.\n        * */\n          releaseLink(link) {\n            try {\n            if (linksCount > 0) { linksCount -= 1; }\n            const linkUI = allLinks[link.id];\n            delete allLinks[link.id];\n\n            linkProgram.removeLink(linkUI);\n\n            const linkIdToRemove = linkUI.id;\n            if (linkIdToRemove < linksCount) {\n              if (linksCount === 0 || linksCount === linkIdToRemove) {\n                return; // no more links or removed link is the last one.\n              }\n\n              const lastLinkUI = links[linksCount];\n              links[linkIdToRemove] = lastLinkUI;\n              lastLinkUI.id = linkIdToRemove;\n            }\n          } catch(err){\n            console.log(err)\n            console.log(link)\n          }\n          },\n\n          /**\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\n        * provider remove node from rendering surface.\n        *\n        * @param nodeUI visual representation of the node created by node() execution.\n        * */\n          releaseNode(node) {\n            if (nodesCount > 0) { nodesCount -= 1; }\n            const nodeUI = allNodes[node.id];\n            delete allNodes[node.id];\n\n            nodeProgram.removeNode(nodeUI);\n\n            const nodeIdToRemove = nodeUI.id;\n            if (nodeIdToRemove < nodesCount) {\n              if (nodesCount === 0 || nodesCount === nodeIdToRemove) {\n                return; // no more nodes or removed node is the last in the list.\n              }\n\n              const lastNodeUI = nodes[nodesCount];\n\n              nodes[nodeIdToRemove] = lastNodeUI;\n              lastNodeUI.id = nodeIdToRemove;\n\n              // Since concrete shaders may cache properties in the UI element\n              // we are letting them to make this swap (e.g. image node shader\n              // uses this approach to update node's offset in the atlas)\n              nodeProgram.replaceProperties(nodeUI, lastNodeUI);\n            }\n          },\n\n          renderNodes() {\n            const pos = { x: 0, y: 0 };\n            // WebGL coordinate system is different. Would be better\n            // to have this transform in the shader code, but it would\n            // require every shader to be updated..\n            for (let i = 0; i < nodesCount; ++i) {\n              const ui = nodes[i];\n              pos.x = ui.position.x;\n              pos.y = ui.position.y;\n              if (userPlaceNodeCallback) {\n                userPlaceNodeCallback(ui, pos);\n              }\n\n              nodeProgram.position(ui, pos);\n            }\n          },\n\n          renderLinks() {\n            if (this.omitLinksRendering) { return; }\n\n            const toPos = { x: 0, y: 0 };\n            const fromPos = { x: 0, y: 0 };\n            for (let i = 0; i < linksCount; ++i) {\n              const ui = links[i];\n              let pos = ui.pos.from;\n              fromPos.x = pos.x;\n              fromPos.y = -pos.y;\n              pos = ui.pos.to;\n              toPos.x = pos.x;\n              toPos.y = -pos.y;\n              if (userPlaceLinkCallback) {\n                userPlaceLinkCallback(ui, fromPos, toPos);\n              }\n\n              linkProgram.position(ui, fromPos, toPos);\n            }\n          },\n\n          /**\n         * Returns root element which hosts graphics.\n         */\n          getGraphicsRoot(callbackWhenReady) {\n            // todo: should fire an event, instead of having this context.\n            if (typeof callbackWhenReady === 'function') {\n              if (graphicsRoot) {\n                callbackWhenReady(graphicsRoot);\n              } else {\n                initCallback = callbackWhenReady;\n              }\n            }\n            return graphicsRoot;\n          },\n\n          /**\n         * Updates default shader which renders nodes\n         *\n         * @param newProgram to use for nodes.\n         */\n          setNodeProgram(newProgram) {\n            if (!gl && newProgram) {\n              // Nothing created yet. Just set shader to the new one\n              // and let initialization logic take care about the rest.\n              nodeProgram = newProgram;\n            } else if (newProgram) {\n              throw 'Not implemented. Cannot swap shader on the fly... Yet.';\n              // TODO: unload old shader and reinit.\n            }\n          },\n\n          /**\n         * Updates default shader which renders links\n         *\n         * @param newProgram to use for links.\n         */\n          setLinkProgram(newProgram) {\n            if (!gl && newProgram) {\n              // Nothing created yet. Just set shader to the new one\n              // and let initialization logic take care about the rest.\n              linkProgram = newProgram;\n            } else if (newProgram) {\n              throw 'Not implemented. Cannot swap shader on the fly... Yet.';\n              // TODO: unload old shader and reinit.\n            }\n          },\n\n          /**\n         * Transforms client coordinates into layout coordinates. Client coordinates\n         * are DOM coordinates relative to the rendering container. Layout\n         * coordinates are those assigned by by layout algorithm to each node.\n         *\n         * @param {Object} p - a point object with `x` and `y` attributes.\n         * This method mutates p.\n         */\n          transformClientToGraphCoordinates(p) {\n          // TODO: could be a problem when container has margins?\n            // normalize\n            p.x = ((2 * p.x) / width) - 1;\n            p.y = 1 - ((2 * p.y) / height);\n\n            // apply transform\n            p.x = (p.x - transform[12]) / transform[0];\n            p.y = (p.y - transform[13]) / transform[5];\n\n            // transform to graph coordinates\n            p.x *= (width / 2);\n            p.y *= (-height / 2);\n\n            return p;\n          },\n\n          /**\n         * Transforms WebGL coordinates into client coordinates. Reverse of\n         * `transformClientToGraphCoordinates()`\n         *\n         * @param {Object} p - a point object with `x` and `y` attributes, which\n         * represents a layout coordinate. This method mutates p.\n         */\n          transformGraphToClientCoordinates(p) {\n          // TODO: could be a problem when container has margins?\n            // transform from graph coordinates\n            p.x /= (width / 2);\n            p.y /= (-height / 2);\n\n            // apply transform\n            p.x = (p.x * transform[0]) + transform[12];\n            p.y = (p.y * transform[5]) + transform[13];\n\n            // denormalize\n            p.x = ((p.x + 1) * width) / 2;\n            p.y = ((1 - p.y) * height) / 2;\n\n            return p;\n          },\n\n          getNodeAtClientPos(clientPos, preciseCheck) {\n            if (typeof preciseCheck !== 'function') {\n              // we don't know anything about your node structure here :(\n              // potentially this could be delegated to node program, but for\n              // right now, we are giving up if you don't pass boundary check\n              // callback. It answers to a question is nodeUI covers  (x, y)\n              return null;\n            }\n            // first transform to graph coordinates:\n            this.transformClientToGraphCoordinates(clientPos);\n            // now using precise check iterate over each node and find one within box:\n            // TODO: This is poor O(N) performance.\n            for (let i = 0; i < nodesCount; ++i) {\n              if (preciseCheck(nodes[i], clientPos.x, clientPos.y)) {\n                return nodes[i].node;\n              }\n            }\n            return null;\n          },\n        };\n\n        // Let graphics fire events before we return it to the caller.\n        eventify(graphics);\n\n        return graphics;\n      }\n    }, {\n      '../Input/webglInputManager.js': 40, '../WebGL/webglLine.js': 62, '../WebGL/webglLinkProgram.js': 63, '../WebGL/webglNodeProgram.js': 64, '../WebGL/webglSquare.js': 65, 'ngraph.events': 9, 'ngraph.merge': 17,\n    }],\n    55: [function (require, module, exports) {\n      module.exports = parseColor;\n\n      function parseColor(color) {\n        let parsedColor = 0x009ee8ff;\n\n        if (typeof color === 'string' && color) {\n          if (color.length === 4) { // #rgb\n            color = color.replace(/([^#])/g, '$1$1'); // duplicate each letter except first #.\n          }\n          if (color.length === 9) { // #rrggbbaa\n            parsedColor = parseInt(color.substr(1), 16);\n          } else if (color.length === 7) { // or #rrggbb.\n            parsedColor = (parseInt(color.substr(1), 16) << 8) | 0xff;\n          } else {\n            throw `Color expected in hex format with preceding \"#\". E.g. #00ff00. Got value: ${color}`;\n          }\n        } else if (typeof color === 'number') {\n          parsedColor = color;\n        }\n\n        return parsedColor;\n      }\n    }, {}],\n    56: [function (require, module, exports) {\n      module.exports = Texture;\n\n      /**\n * Single texture in the webglAtlas.\n */\n      function Texture(size) {\n        this.canvas = window.document.createElement('canvas');\n        this.ctx = this.canvas.getContext('2d');\n        this.isDirty = false;\n        this.canvas.width = this.canvas.height = size;\n      }\n    }, {}],\n    57: [function (require, module, exports) {\n    /**\n * @fileOverview Utility functions for webgl rendering.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\n      module.exports = webgl;\n\n      function webgl(gl) {\n        return {\n          createProgram,\n          extendArray,\n          copyArrayPart,\n          swapArrayPart,\n          getLocations,\n          context: gl,\n        };\n\n        function createShader(shaderText, type) {\n          const shader = gl.createShader(type);\n          gl.shaderSource(shader, shaderText);\n          gl.compileShader(shader);\n\n          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            const msg = gl.getShaderInfoLog(shader);\n            window.alert(msg);\n            throw msg;\n          }\n\n          return shader;\n        }\n\n        function createProgram(vertexShaderSrc, fragmentShaderSrc) {\n          const program = gl.createProgram();\n          const vs = createShader(vertexShaderSrc, gl.VERTEX_SHADER);\n          const fs = createShader(fragmentShaderSrc, gl.FRAGMENT_SHADER);\n\n          gl.attachShader(program, vs);\n          gl.attachShader(program, fs);\n          gl.linkProgram(program);\n\n          if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            const msg = gl.getShaderInfoLog(program);\n            window.alert(msg);\n            throw msg;\n          }\n\n          return program;\n        }\n\n        function extendArray(buffer, itemsInBuffer, elementsPerItem) {\n          if ((itemsInBuffer + 1) * elementsPerItem > buffer.length) {\n          // Every time we run out of space create new array twice bigger.\n          // TODO: it seems buffer size is limited. Consider using multiple arrays for huge graphs\n            const extendedArray = new Float32Array(buffer.length * elementsPerItem * 2);\n            extendedArray.set(buffer);\n\n            return extendedArray;\n          }\n\n          return buffer;\n        }\n\n        function getLocations(program, uniformOrAttributeNames) {\n          const foundLocations = {};\n          for (let i = 0; i < uniformOrAttributeNames.length; ++i) {\n            const name = uniformOrAttributeNames[i];\n            let location = -1;\n            if (name[0] === 'a' && name[1] === '_') {\n              location = gl.getAttribLocation(program, name);\n              if (location === -1) {\n                throw new Error(`Program doesn't have required attribute: ${name}`);\n              }\n\n              foundLocations[name.slice(2)] = location;\n            } else if (name[0] === 'u' && name[1] === '_') {\n              location = gl.getUniformLocation(program, name);\n              if (location === null) {\n                throw new Error(`Program doesn't have required uniform: ${name}`);\n              }\n\n              foundLocations[name.slice(2)] = location;\n            } else {\n              throw new Error(\"Couldn't figure out your intent. All uniforms should start with 'u_' prefix, and attributes with 'a_'\");\n            }\n          }\n\n          return foundLocations;\n        }\n      }\n\n      function copyArrayPart(array, to, from, elementsCount) {\n        for (let i = 0; i < elementsCount; ++i) {\n          array[to + i] = array[from + i];\n        }\n      }\n\n      function swapArrayPart(array, from, to, elementsCount) {\n        for (let i = 0; i < elementsCount; ++i) {\n          const tmp = array[from + i];\n          array[from + i] = array[to + i];\n          array[to + i] = tmp;\n        }\n      }\n    }, {}],\n    58: [function (require, module, exports) {\n      const Texture = require('./texture.js');\n\n      module.exports = webglAtlas;\n\n      /**\n * My naive implementation of textures atlas. It allows clients to load\n * multiple images into atlas and get canvas representing all of them.\n *\n * @param tilesPerTexture - indicates how many images can be loaded to one\n *          texture of the atlas. If number of loaded images exceeds this\n *          parameter a new canvas will be created.\n */\n      function webglAtlas(tilesPerTexture) {\n        let tilesPerRow = Math.sqrt(tilesPerTexture || 1024) << 0,\n          tileSize = tilesPerRow,\n          lastLoadedIdx = 1,\n          loadedImages = {},\n          dirtyTimeoutId,\n          skipedDirty = 0,\n          textures = [],\n          trackedUrls = [];\n\n        if (!isPowerOf2(tilesPerTexture)) {\n          throw 'Tiles per texture should be power of two.';\n        }\n\n        // this is the return object\n        const api = {\n        /**\n     * indicates whether atlas has changed texture in it. If true then\n     * some of the textures has isDirty flag set as well.\n     */\n          isDirty: false,\n\n          /**\n     * Clears any signs of atlas changes.\n     */\n          clearDirty,\n\n          /**\n     * Removes given url from collection of tiles in the atlas.\n     */\n          remove,\n\n          /**\n     * Gets all textures in the atlas.\n     */\n          getTextures,\n\n          /**\n     * Gets coordinates of the given image in the atlas. Coordinates is an object:\n     * {offset : int } - where offset is an absolute position of the image in the\n     * atlas.\n     *\n     * Absolute means it can be larger than tilesPerTexture parameter, and in that\n     * case clients should get next texture in getTextures() collection.\n     */\n          getCoordinates,\n\n          /**\n     * Asynchronously Loads the image to the atlas. Cross-domain security\n     * limitation applies.\n     */\n          load,\n        };\n\n        return api;\n\n        function clearDirty() {\n          let i;\n          api.isDirty = false;\n          for (i = 0; i < textures.length; ++i) {\n            textures[i].isDirty = false;\n          }\n        }\n\n        function remove(imgUrl) {\n          const coordinates = loadedImages[imgUrl];\n          if (!coordinates) {\n            return false;\n          }\n          delete loadedImages[imgUrl];\n          lastLoadedIdx -= 1;\n\n\n          if (lastLoadedIdx === coordinates.offset) {\n            return true; // Ignore if it's last image in the whole set.\n          }\n\n          let tileToRemove = getTileCoordinates(coordinates.offset),\n            lastTileInSet = getTileCoordinates(lastLoadedIdx);\n\n          copy(lastTileInSet, tileToRemove);\n\n          const replacedOffset = loadedImages[trackedUrls[lastLoadedIdx]];\n          replacedOffset.offset = coordinates.offset;\n          trackedUrls[coordinates.offset] = trackedUrls[lastLoadedIdx];\n\n          markDirty();\n          return true;\n        }\n\n        function getTextures() {\n          return textures; // I trust you...\n        }\n\n        function getCoordinates(imgUrl) {\n          return loadedImages[imgUrl];\n        }\n\n        function load(imgUrl, callback) {\n          if (loadedImages.hasOwnProperty(imgUrl)) {\n            callback(loadedImages[imgUrl]);\n          } else {\n            let img = new window.Image(),\n              imgId = lastLoadedIdx;\n\n            lastLoadedIdx += 1;\n            img.crossOrigin = 'anonymous';\n            img.onload = function () {\n              markDirty();\n              drawAt(imgId, img, callback);\n            };\n\n            img.src = imgUrl;\n          }\n        }\n\n        function createTexture() {\n          const texture = new Texture(tilesPerRow * tileSize);\n          textures.push(texture);\n        }\n\n        function drawAt(tileNumber, img, callback) {\n          let tilePosition = getTileCoordinates(tileNumber),\n            coordinates = {\n              offset: tileNumber,\n            };\n\n          if (tilePosition.textureNumber >= textures.length) {\n            createTexture();\n          }\n          const currentTexture = textures[tilePosition.textureNumber];\n\n          currentTexture.ctx.drawImage(img, tilePosition.col * tileSize, tilePosition.row * tileSize, tileSize, tileSize);\n          trackedUrls[tileNumber] = img.src;\n\n          loadedImages[img.src] = coordinates;\n          currentTexture.isDirty = true;\n\n          callback(coordinates);\n        }\n\n        function getTileCoordinates(absolutePosition) {\n          let textureNumber = (absolutePosition / tilesPerTexture) << 0,\n            localTileNumber = (absolutePosition % tilesPerTexture),\n            row = (localTileNumber / tilesPerRow) << 0,\n            col = (localTileNumber % tilesPerRow);\n\n          return {\n            textureNumber,\n            row,\n            col,\n          };\n        }\n\n        function markDirtyNow() {\n          api.isDirty = true;\n          skipedDirty = 0;\n          dirtyTimeoutId = null;\n        }\n\n        function markDirty() {\n        // delay this call, since it results in texture reload\n          if (dirtyTimeoutId) {\n            window.clearTimeout(dirtyTimeoutId);\n            skipedDirty += 1;\n            dirtyTimeoutId = null;\n          }\n\n          if (skipedDirty > 10) {\n            markDirtyNow();\n          } else {\n            dirtyTimeoutId = window.setTimeout(markDirtyNow, 400);\n          }\n        }\n\n        function copy(from, to) {\n          let fromCanvas = textures[from.textureNumber].canvas,\n            toCtx = textures[to.textureNumber].ctx,\n            x = to.col * tileSize,\n            y = to.row * tileSize;\n\n          toCtx.drawImage(fromCanvas, from.col * tileSize, from.row * tileSize, tileSize, tileSize, x, y, tileSize, tileSize);\n          textures[from.textureNumber].isDirty = true;\n          textures[to.textureNumber].isDirty = true;\n        }\n      }\n\n      function isPowerOf2(n) {\n        return (n & (n - 1)) === 0;\n      }\n    }, { './texture.js': 56 }],\n    59: [function (require, module, exports) {\n      module.exports = webglImage;\n\n      /**\n * Represents a model for image.\n */\n      function webglImage(size, src) {\n        return {\n        /**\n         * Gets texture index where current image is placed.\n         */\n          _texture: 0,\n\n          /**\n         * Gets offset in the texture where current image is placed.\n         */\n          _offset: 0,\n\n          /**\n         * Gets size of the square with the image.\n         */\n          size: typeof size === 'number' ? size : 32,\n\n          /**\n         * Source of the image. If image is coming not from your domain\n         * certain origin restrictions applies.\n         * See http://www.khronos.org/registry/webgl/specs/latest/#4.2 for more details.\n         */\n          src,\n        };\n      }\n    }, {}],\n    60: [function (require, module, exports) {\n    /**\n * @fileOverview Defines an image nodes for webglGraphics class.\n * Shape of nodes is square.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\n      const WebglAtlas = require('./webglAtlas.js');\n      const glUtils = require('./webgl.js');\n\n      module.exports = webglImageNodeProgram;\n\n      /**\n * Defines simple UI for nodes in webgl renderer. Each node is rendered as an image.\n */\n      function webglImageNodeProgram() {\n      // WebGL is gian state machine, we store some properties of the state here:\n        const ATTRIBUTES_PER_PRIMITIVE = 18;\n        const nodesFS = createNodeFragmentShader();\n        const nodesVS = createNodeVertexShader();\n        const tilesPerTexture = 1024; // TODO: Get based on max texture size\n        let atlas;\n        let program;\n        let gl;\n        let buffer;\n        let utils;\n        let locations;\n        let nodesCount = 0;\n        let nodes = new Float32Array(64);\n        let width;\n        let height;\n        let transform;\n        let sizeDirty;\n\n\n        return {\n          load,\n\n          /**\n     * Updates position of current node in the buffer of nodes.\n     *\n     * @param idx - index of current node.\n     * @param pos - new position of the node.\n     */\n          position,\n\n          createNode,\n\n          removeNode,\n\n          replaceProperties,\n\n          updateTransform,\n\n          updateSize,\n\n          render,\n        };\n\n        function refreshTexture(texture, idx) {\n          if (texture.nativeObject) {\n            gl.deleteTexture(texture.nativeObject);\n          }\n\n          const nativeObject = gl.createTexture();\n          gl.activeTexture(gl[`TEXTURE${idx}`]);\n          gl.bindTexture(gl.TEXTURE_2D, nativeObject);\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.canvas);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n\n          gl.generateMipmap(gl.TEXTURE_2D);\n          gl.uniform1i(locations[`sampler${idx}`], idx);\n\n          texture.nativeObject = nativeObject;\n        }\n\n        function ensureAtlasTextureUpdated() {\n          if (atlas.isDirty) {\n            let textures = atlas.getTextures(),\n              i;\n            for (i = 0; i < textures.length; ++i) {\n              if (textures[i].isDirty || !textures[i].nativeObject) {\n                refreshTexture(textures[i], i);\n              }\n            }\n\n            atlas.clearDirty();\n          }\n        }\n\n        function load(glContext) {\n          gl = glContext;\n          utils = glUtils(glContext);\n\n          atlas = new WebglAtlas(tilesPerTexture);\n\n          program = utils.createProgram(nodesVS, nodesFS);\n          gl.useProgram(program);\n          locations = utils.getLocations(program, ['a_vertexPos', 'a_customAttributes', 'u_screenSize', 'u_transform', 'u_sampler0', 'u_sampler1', 'u_sampler2', 'u_sampler3', 'u_tilesPerTexture']);\n\n          gl.uniform1f(locations.tilesPerTexture, tilesPerTexture);\n\n          gl.enableVertexAttribArray(locations.vertexPos);\n          gl.enableVertexAttribArray(locations.customAttributes);\n\n          buffer = gl.createBuffer();\n        }\n\n        function position(nodeUI, pos) {\n          const idx = nodeUI.id * ATTRIBUTES_PER_PRIMITIVE;\n          nodes[idx] = pos.x - nodeUI.size;\n          nodes[idx + 1] = pos.y - nodeUI.size;\n          nodes[idx + 2] = nodeUI._offset * 4;\n\n          nodes[idx + 3] = pos.x + nodeUI.size;\n          nodes[idx + 4] = pos.y - nodeUI.size;\n          nodes[idx + 5] = nodeUI._offset * 4 + 1;\n\n          nodes[idx + 6] = pos.x - nodeUI.size;\n          nodes[idx + 7] = pos.y + nodeUI.size;\n          nodes[idx + 8] = nodeUI._offset * 4 + 2;\n\n          nodes[idx + 9] = pos.x - nodeUI.size;\n          nodes[idx + 10] = pos.y + nodeUI.size;\n          nodes[idx + 11] = nodeUI._offset * 4 + 2;\n\n          nodes[idx + 12] = pos.x + nodeUI.size;\n          nodes[idx + 13] = pos.y - nodeUI.size;\n          nodes[idx + 14] = nodeUI._offset * 4 + 1;\n\n          nodes[idx + 15] = pos.x + nodeUI.size;\n          nodes[idx + 16] = pos.y + nodeUI.size;\n          nodes[idx + 17] = nodeUI._offset * 4 + 3;\n        }\n\n        function createNode(ui) {\n          nodes = utils.extendArray(nodes, nodesCount, ATTRIBUTES_PER_PRIMITIVE);\n          nodesCount += 1;\n\n          const coordinates = atlas.getCoordinates(ui.src);\n          if (coordinates) {\n            ui._offset = coordinates.offset;\n          } else {\n            ui._offset = 0;\n            // Image is not yet loaded into the atlas. Reload it:\n            atlas.load(ui.src, (coordinates) => {\n              ui._offset = coordinates.offset;\n            });\n          }\n        }\n\n        function removeNode(nodeUI) {\n          if (nodesCount > 0) {\n            nodesCount -= 1;\n          }\n\n          if (nodeUI.id < nodesCount && nodesCount > 0) {\n            if (nodeUI.src) {\n              atlas.remove(nodeUI.src);\n            }\n\n            utils.copyArrayPart(nodes, nodeUI.id * ATTRIBUTES_PER_PRIMITIVE, nodesCount * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n          }\n        }\n\n        function replaceProperties(replacedNode, newNode) {\n          newNode._offset = replacedNode._offset;\n        }\n\n        function updateTransform(newTransform) {\n          sizeDirty = true;\n          transform = newTransform;\n        }\n\n        function updateSize(w, h) {\n          width = w;\n          height = h;\n          sizeDirty = true;\n        }\n\n        function render() {\n          gl.useProgram(program);\n          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n          gl.bufferData(gl.ARRAY_BUFFER, nodes, gl.DYNAMIC_DRAW);\n\n          if (sizeDirty) {\n            sizeDirty = false;\n            gl.uniformMatrix4fv(locations.transform, false, transform);\n            gl.uniform2f(locations.screenSize, width, height);\n          }\n\n          gl.vertexAttribPointer(locations.vertexPos, 2, gl.FLOAT, false, 3 * Float32Array.BYTES_PER_ELEMENT, 0);\n          gl.vertexAttribPointer(locations.customAttributes, 1, gl.FLOAT, false, 3 * Float32Array.BYTES_PER_ELEMENT, 2 * 4);\n\n          ensureAtlasTextureUpdated();\n\n          gl.drawArrays(gl.TRIANGLES, 0, nodesCount * 6);\n        }\n      }\n\n      // TODO: Use glslify for shaders\n      function createNodeFragmentShader() {\n        return [\n          'precision mediump float;',\n          'varying vec4 color;',\n          'varying vec3 vTextureCoord;',\n          'uniform sampler2D u_sampler0;',\n          'uniform sampler2D u_sampler1;',\n          'uniform sampler2D u_sampler2;',\n          'uniform sampler2D u_sampler3;',\n\n          'void main(void) {',\n          '   if (vTextureCoord.z == 0.) {',\n          '     gl_FragColor = texture2D(u_sampler0, vTextureCoord.xy);',\n          '   } else if (vTextureCoord.z == 1.) {',\n          '     gl_FragColor = texture2D(u_sampler1, vTextureCoord.xy);',\n          '   } else if (vTextureCoord.z == 2.) {',\n          '     gl_FragColor = texture2D(u_sampler2, vTextureCoord.xy);',\n          '   } else if (vTextureCoord.z == 3.) {',\n          '     gl_FragColor = texture2D(u_sampler3, vTextureCoord.xy);',\n          '   } else { gl_FragColor = vec4(0, 1, 0, 1); }',\n          '}',\n        ].join('\\n');\n      }\n\n      function createNodeVertexShader() {\n        return [\n          'attribute vec2 a_vertexPos;',\n\n          'attribute float a_customAttributes;',\n          'uniform vec2 u_screenSize;',\n          'uniform mat4 u_transform;',\n          'uniform float u_tilesPerTexture;',\n          'varying vec3 vTextureCoord;',\n\n          'void main(void) {',\n          '   gl_Position = u_transform * vec4(a_vertexPos/u_screenSize, 0, 1);',\n          'float corner = mod(a_customAttributes, 4.);',\n          'float tileIndex = mod(floor(a_customAttributes / 4.), u_tilesPerTexture);',\n          'float tilesPerRow = sqrt(u_tilesPerTexture);',\n          'float tileSize = 1./tilesPerRow;',\n          'float tileColumn = mod(tileIndex, tilesPerRow);',\n          'float tileRow = floor(tileIndex/tilesPerRow);',\n\n          'if(corner == 0.0) {',\n          '  vTextureCoord.xy = vec2(0, 1);',\n          '} else if(corner == 1.0) {',\n          '  vTextureCoord.xy = vec2(1, 1);',\n          '} else if(corner == 2.0) {',\n          '  vTextureCoord.xy = vec2(0, 0);',\n          '} else {',\n          '  vTextureCoord.xy = vec2(1, 0);',\n          '}',\n\n          'vTextureCoord *= tileSize;',\n          'vTextureCoord.x += tileColumn * tileSize;',\n          'vTextureCoord.y += tileRow * tileSize;',\n          'vTextureCoord.z = floor(floor(a_customAttributes / 4.)/u_tilesPerTexture);',\n          '}',\n        ].join('\\n');\n      }\n    }, { './webgl.js': 57, './webglAtlas.js': 58 }],\n    61: [function (require, module, exports) {\n      const documentEvents = require('../Utils/documentEvents.js');\n\n      module.exports = webglInputEvents;\n\n      /**\n * Monitors graph-related mouse input in webgl graphics and notifies subscribers.\n *\n * @param {Viva.Graph.View.webglGraphics} webglGraphics\n */\n      function webglInputEvents(webglGraphics) {\n        if (webglGraphics.webglInputEvents) {\n        // Don't listen twice, if we are already attached to this graphics:\n          return webglGraphics.webglInputEvents;\n        }\n\n        let mouseCapturedNode = null,\n          mouseEnterCallback = [],\n          mouseLeaveCallback = [],\n          mouseDownCallback = [],\n          mouseUpCallback = [],\n          mouseMoveCallback = [],\n          clickCallback = [],\n          dblClickCallback = [],\n          prevSelectStart,\n          boundRect;\n\n        const root = webglGraphics.getGraphicsRoot();\n        startListen(root);\n\n        const api = {\n          mouseEnter,\n          mouseLeave,\n          mouseDown,\n          mouseUp,\n          mouseMove,\n          click,\n          dblClick,\n          mouseCapture,\n          releaseMouseCapture,\n        };\n\n        // TODO I don't remember why this is needed:\n        webglGraphics.webglInputEvents = api;\n\n        return api;\n\n        function releaseMouseCapture() {\n          mouseCapturedNode = null;\n        }\n\n        function mouseCapture(node) {\n          mouseCapturedNode = node;\n        }\n\n        function dblClick(callback) {\n          if (typeof callback === 'function') {\n            dblClickCallback.push(callback);\n          }\n          return api;\n        }\n\n        function click(callback) {\n          if (typeof callback === 'function') {\n            clickCallback.push(callback);\n          }\n          return api;\n        }\n\n        function mouseMove(callback) {\n          if (typeof callback === 'function') {\n            mouseMoveCallback.push(callback);\n          }\n          return api;\n        }\n\n        function mouseUp(callback) {\n          if (typeof callback === 'function') {\n            mouseUpCallback.push(callback);\n          }\n          return api;\n        }\n\n        function mouseDown(callback) {\n          if (typeof callback === 'function') {\n            mouseDownCallback.push(callback);\n          }\n          return api;\n        }\n\n        function mouseLeave(callback) {\n          if (typeof callback === 'function') {\n            mouseLeaveCallback.push(callback);\n          }\n          return api;\n        }\n\n        function mouseEnter(callback) {\n          if (typeof callback === 'function') {\n            mouseEnterCallback.push(callback);\n          }\n          return api;\n        }\n\n        function preciseCheck(nodeUI, x, y) {\n          if (nodeUI && nodeUI.size) {\n            let pos = nodeUI.position,\n              half = nodeUI.size;\n\n            return pos.x - half < x && x < pos.x + half &&\n        pos.y - half < y && y < pos.y + half;\n          }\n\n          return true;\n        }\n\n        function getNodeAtClientPos(pos) {\n          return webglGraphics.getNodeAtClientPos(pos, preciseCheck);\n        }\n\n        function stopPropagation(e) {\n          if (e.stopPropagation) {\n            e.stopPropagation();\n          } else {\n            e.cancelBubble = true;\n          }\n        }\n\n        function handleDisabledEvent(e) {\n          stopPropagation(e);\n          return false;\n        }\n\n        function invoke(callbacksChain, args) {\n          let i,\n            stopPropagation;\n          for (i = 0; i < callbacksChain.length; i += 1) {\n            stopPropagation = callbacksChain[i].apply(undefined, args);\n            if (stopPropagation) {\n              return true;\n            }\n          }\n        }\n\n        function startListen(root) {\n          var pos = {\n              x: 0,\n              y: 0,\n            },\n            lastFound = null,\n            lastUpdate = 1,\n            lastClickTime = +new Date(),\n\n            handleMouseMove = function (e) {\n              invoke(mouseMoveCallback, [lastFound, e]);\n              pos.x = e.clientX;\n              pos.y = e.clientY;\n            },\n\n            handleMouseUp = function () {\n              documentEvents.off('mousemove', handleMouseMove);\n              documentEvents.off('mouseup', handleMouseUp);\n            },\n\n            updateBoundRect = function () {\n              boundRect = root.getBoundingClientRect();\n            };\n\n          window.addEventListener('resize', updateBoundRect);\n          updateBoundRect();\n\n          // mouse move inside container serves only to track mouse enter/leave events.\n          root.addEventListener(\n            'mousemove',\n            (e) => {\n              if (mouseCapturedNode) {\n                return;\n              }\n              if (lastUpdate++ % 7 === 0) {\n                // since there is no bullet proof method to detect resize\n                // event, we preemptively update the bounding rectangle\n                updateBoundRect();\n                lastUpdate = 1;\n              }\n              let cancelBubble = false,\n                node;\n\n              pos.x = e.clientX - boundRect.left;\n              pos.y = e.clientY - boundRect.top;\n\n              node = getNodeAtClientPos(pos);\n\n              if (node && lastFound !== node) {\n                lastFound = node;\n                cancelBubble = cancelBubble || invoke(mouseEnterCallback, [lastFound]);\n              } else if (node === null && lastFound !== node) {\n                cancelBubble = cancelBubble || invoke(mouseLeaveCallback, [lastFound]);\n                lastFound = null;\n              }\n\n              if (cancelBubble) {\n                stopPropagation(e);\n              }\n            },\n          );\n\n          root.addEventListener(\n            'mousedown',\n            (e) => {\n              let cancelBubble = false,\n                args;\n              updateBoundRect();\n              pos.x = e.clientX - boundRect.left;\n              pos.y = e.clientY - boundRect.top;\n\n              args = [getNodeAtClientPos(pos), e];\n              if (args[0]) {\n                cancelBubble = invoke(mouseDownCallback, args);\n                // we clicked on a node. Following drag should be handled on document events:\n                documentEvents.on('mousemove', handleMouseMove);\n                documentEvents.on('mouseup', handleMouseUp);\n\n                prevSelectStart = window.document.onselectstart;\n\n                window.document.onselectstart = handleDisabledEvent;\n\n                lastFound = args[0];\n              } else {\n                lastFound = null;\n              }\n              if (cancelBubble) {\n                stopPropagation(e);\n              }\n            },\n          );\n\n          root.addEventListener(\n            'mouseup',\n            (e) => {\n              let clickTime = +new Date(),\n                args;\n\n              pos.x = e.clientX - boundRect.left;\n              pos.y = e.clientY - boundRect.top;\n\n              const nodeAtClientPos = getNodeAtClientPos(pos);\n              const sameNode = nodeAtClientPos === lastFound;\n              args = [nodeAtClientPos || lastFound, e];\n              if (args[0]) {\n                window.document.onselectstart = prevSelectStart;\n\n                if (clickTime - lastClickTime < 400 && sameNode) {\n                  invoke(dblClickCallback, args);\n                } else {\n                  invoke(clickCallback, args);\n                }\n                lastClickTime = clickTime;\n\n                if (invoke(mouseUpCallback, args)) {\n                  stopPropagation(e);\n                }\n              }\n            },\n          );\n        }\n      }\n    }, { '../Utils/documentEvents.js': 44 }],\n    62: [function (require, module, exports) {\n      const parseColor = require('./parseColor.js');\n\n      module.exports = webglLine;\n\n      /**\n * Defines a webgl line. This class has no rendering logic at all,\n * it's just passed to corresponding shader and the shader should\n * figure out how to render it.\n *\n */\n      function webglLine(color) {\n        return {\n        /**\n     * Gets or sets color of the line. If you set this property externally\n     * make sure it always come as integer of 0xRRGGBBAA format\n     */\n          color: parseColor(color),\n        };\n      }\n    }, { './parseColor.js': 55 }],\n    63: [function (require, module, exports) {\n    /**\n * @fileOverview Defines a naive form of links for webglGraphics class.\n * This form allows to change color of links.\n * */\n\n      const glUtils = require('./webgl.js');\n\n      module.exports = webglLinkProgram;\n\n      /**\n * Defines UI for links in webgl renderer.\n */\n      function webglLinkProgram() {\n        let ATTRIBUTES_PER_PRIMITIVE = 6, // primitive is Line with two points. Each has x,y and color = 3 * 2 attributes.\n          BYTES_PER_LINK = 2 * (2 * Float32Array.BYTES_PER_ELEMENT + Uint32Array.BYTES_PER_ELEMENT), // two nodes * (x, y + color)\n          linksFS = [\n            'precision mediump float;',\n            'varying vec4 color;',\n            'void main(void) {',\n            '   gl_FragColor = color;',\n            '}',\n          ].join('\\n'),\n\n          linksVS = [\n            'attribute vec2 a_vertexPos;',\n            'attribute vec4 a_color;',\n\n            'uniform vec2 u_screenSize;',\n            'uniform mat4 u_transform;',\n\n            'varying vec4 color;',\n\n            'void main(void) {',\n            '   gl_Position = u_transform * vec4(a_vertexPos/u_screenSize, 0.0, 1.0);',\n            '   color = a_color.abgr;',\n            '}',\n          ].join('\\n'),\n\n          program,\n          gl,\n          buffer,\n          utils,\n          locations,\n          linksCount = 0,\n          frontLinkId, // used to track z-index of links.\n          storage = new ArrayBuffer(16 * BYTES_PER_LINK),\n          positions = new Float32Array(storage),\n          colors = new Uint32Array(storage),\n          width,\n          height,\n          transform,\n          sizeDirty,\n\n          ensureEnoughStorage = function () {\n          // TODO: this is a duplicate of webglNodeProgram code. Extract it to webgl.js\n            if ((linksCount + 1) * BYTES_PER_LINK > storage.byteLength) {\n            // Every time we run out of space create new array twice bigger.\n            // TODO: it seems buffer size is limited. Consider using multiple arrays for huge graphs\n              let extendedStorage = new ArrayBuffer(storage.byteLength * 2),\n                extendedPositions = new Float32Array(extendedStorage),\n                extendedColors = new Uint32Array(extendedStorage);\n\n              extendedColors.set(colors); // should be enough to copy just one view.\n              positions = extendedPositions;\n              colors = extendedColors;\n              storage = extendedStorage;\n            }\n          };\n\n        return {\n          load(glContext) {\n            gl = glContext;\n            utils = glUtils(glContext);\n\n            program = utils.createProgram(linksVS, linksFS);\n            gl.useProgram(program);\n            locations = utils.getLocations(program, ['a_vertexPos', 'a_color', 'u_screenSize', 'u_transform']);\n\n            gl.enableVertexAttribArray(locations.vertexPos);\n            gl.enableVertexAttribArray(locations.color);\n\n            buffer = gl.createBuffer();\n          },\n\n          position(linkUi, fromPos, toPos) {\n            let linkIdx = linkUi.id,\n              offset = linkIdx * ATTRIBUTES_PER_PRIMITIVE;\n            positions[offset] = fromPos.x;\n            positions[offset + 1] = fromPos.y;\n            colors[offset + 2] = linkUi.color;\n\n            positions[offset + 3] = toPos.x;\n            positions[offset + 4] = toPos.y;\n            colors[offset + 5] = linkUi.color;\n          },\n\n          createLink(ui) {\n            ensureEnoughStorage();\n\n            linksCount += 1;\n            frontLinkId = ui.id;\n          },\n\n          removeLink(ui) {\n            if (linksCount > 0) { linksCount -= 1; }\n            // swap removed link with the last link. This will give us O(1) performance for links removal:\n            try{\n            if (ui.id < linksCount && linksCount > 0) {\n              // using colors as a view to array buffer is okay here.\n              utils.copyArrayPart(colors, ui.id * ATTRIBUTES_PER_PRIMITIVE, linksCount * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n            }\n          } catch(err) {\n            console.log('removeLinkErr')\n          }\n          },\n\n          updateTransform(newTransform) {\n            sizeDirty = true;\n            transform = newTransform;\n          },\n\n          updateSize(w, h) {\n            width = w;\n            height = h;\n            sizeDirty = true;\n          },\n\n          render() {\n            gl.useProgram(program);\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, storage, gl.DYNAMIC_DRAW);\n\n            if (sizeDirty) {\n              sizeDirty = false;\n              gl.uniformMatrix4fv(locations.transform, false, transform);\n              gl.uniform2f(locations.screenSize, width, height);\n            }\n\n            gl.vertexAttribPointer(locations.vertexPos, 2, gl.FLOAT, false, 3 * Float32Array.BYTES_PER_ELEMENT, 0);\n            gl.vertexAttribPointer(locations.color, 4, gl.UNSIGNED_BYTE, true, 3 * Float32Array.BYTES_PER_ELEMENT, 2 * 4);\n\n            gl.drawArrays(gl.LINES, 0, linksCount * 2);\n\n            frontLinkId = linksCount - 1;\n          },\n\n          bringToFront(link) {\n            if (frontLinkId > link.id) {\n              utils.swapArrayPart(positions, link.id * ATTRIBUTES_PER_PRIMITIVE, frontLinkId * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n            }\n            if (frontLinkId > 0) {\n              frontLinkId -= 1;\n            }\n          },\n\n          getFrontLinkId() {\n            return frontLinkId;\n          },\n        };\n      }\n    }, { './webgl.js': 57 }],\n    64: [function (require, module, exports) {\n    /**\n * @fileOverview Defines a naive form of nodes for webglGraphics class.\n * This form allows to change color of node. Shape of nodes is rectangular.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\n      const glUtils = require('./webgl.js');\n\n      module.exports = webglNodeProgram;\n\n      /**\n * Defines simple UI for nodes in webgl renderer. Each node is rendered as square. Color and size can be changed.\n */\n      function webglNodeProgram() {\n        const ATTRIBUTES_PER_PRIMITIVE = 4; // Primitive is point, x, y, size, color\n        // x, y, z - floats, color = uint.\n        const BYTES_PER_NODE = 3 * Float32Array.BYTES_PER_ELEMENT + Uint32Array.BYTES_PER_ELEMENT;\n        const nodesFS = [\n          'precision mediump float;',\n          'varying vec4 color;',\n\n          'void main(void) {',\n          '   gl_FragColor = color;',\n          '}',\n        ].join('\\n');\n        const nodesVS = [\n          'attribute vec3 a_vertexPos;',\n          'attribute vec4 a_color;',\n          'uniform vec2 u_screenSize;',\n          'uniform mat4 u_transform;',\n          'varying vec4 color;',\n\n          'void main(void) {',\n          '   gl_Position = u_transform * vec4(a_vertexPos.xy/u_screenSize, 0, 1);',\n          '   gl_PointSize = a_vertexPos.z * u_transform[0][0];',\n          '   color = a_color.abgr;',\n          '}',\n        ].join('\\n');\n\n        let program;\n        let gl;\n        let buffer;\n        let locations;\n        let utils;\n        let storage = new ArrayBuffer(16 * BYTES_PER_NODE);\n        let positions = new Float32Array(storage);\n        let colors = new Uint32Array(storage);\n        let nodesCount = 0;\n        let width;\n        let height;\n        let transform;\n        let sizeDirty;\n\n        return {\n          load,\n\n          /**\n     * Updates position of node in the buffer of nodes.\n     *\n     * @param idx - index of current node.\n     * @param pos - new position of the node.\n     */\n          position,\n\n          updateTransform,\n\n          updateSize,\n\n          removeNode,\n\n          createNode,\n\n          replaceProperties,\n\n          render,\n        };\n\n        function ensureEnoughStorage() {\n          if ((nodesCount + 1) * BYTES_PER_NODE >= storage.byteLength) {\n          // Every time we run out of space create new array twice bigger.\n          // TODO: it seems buffer size is limited. Consider using multiple arrays for huge graphs\n            let extendedStorage = new ArrayBuffer(storage.byteLength * 2),\n              extendedPositions = new Float32Array(extendedStorage),\n              extendedColors = new Uint32Array(extendedStorage);\n\n            extendedColors.set(colors); // should be enough to copy just one view.\n            positions = extendedPositions;\n            colors = extendedColors;\n            storage = extendedStorage;\n          }\n        }\n\n        function load(glContext) {\n          gl = glContext;\n          utils = glUtils(glContext);\n\n          program = utils.createProgram(nodesVS, nodesFS);\n          gl.useProgram(program);\n          locations = utils.getLocations(program, ['a_vertexPos', 'a_color', 'u_screenSize', 'u_transform']);\n\n          gl.enableVertexAttribArray(locations.vertexPos);\n          gl.enableVertexAttribArray(locations.color);\n\n          buffer = gl.createBuffer();\n        }\n\n        function position(nodeUI, pos) {\n          const idx = nodeUI.id;\n\n          positions[idx * ATTRIBUTES_PER_PRIMITIVE] = pos.x;\n          positions[idx * ATTRIBUTES_PER_PRIMITIVE + 1] = -pos.y;\n          positions[idx * ATTRIBUTES_PER_PRIMITIVE + 2] = nodeUI.size;\n\n          colors[idx * ATTRIBUTES_PER_PRIMITIVE + 3] = nodeUI.color;\n        }\n\n        function updateTransform(newTransform) {\n          sizeDirty = true;\n          transform = newTransform;\n        }\n\n        function updateSize(w, h) {\n          width = w;\n          height = h;\n          sizeDirty = true;\n        }\n\n        function removeNode(node) {\n          if (nodesCount > 0) {\n            nodesCount -= 1;\n          }\n\n          if (node.id < nodesCount && nodesCount > 0) {\n            // we can use colors as a 'view' into array array buffer.\n            utils.copyArrayPart(colors, node.id * ATTRIBUTES_PER_PRIMITIVE, nodesCount * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n          }\n        }\n\n        function createNode() {\n          ensureEnoughStorage();\n          nodesCount += 1;\n        }\n\n        function replaceProperties(/* replacedNode, newNode */) {}\n\n        function render() {\n          gl.useProgram(program);\n          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n          gl.bufferData(gl.ARRAY_BUFFER, storage, gl.DYNAMIC_DRAW);\n\n          if (sizeDirty) {\n            sizeDirty = false;\n            gl.uniformMatrix4fv(locations.transform, false, transform);\n            gl.uniform2f(locations.screenSize, width, height);\n          }\n\n          gl.vertexAttribPointer(locations.vertexPos, 3, gl.FLOAT, false, ATTRIBUTES_PER_PRIMITIVE * Float32Array.BYTES_PER_ELEMENT, 0);\n          gl.vertexAttribPointer(locations.color, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES_PER_PRIMITIVE * Float32Array.BYTES_PER_ELEMENT, 3 * 4);\n\n          gl.drawArrays(gl.POINTS, 0, nodesCount);\n        }\n      }\n    }, { './webgl.js': 57 }],\n    65: [function (require, module, exports) {\n      const parseColor = require('./parseColor.js');\n\n      module.exports = webglSquare;\n\n      /**\n * Can be used as a callback in the webglGraphics.node() function, to\n * create a custom looking node.\n *\n * @param size - size of the node in pixels.\n * @param color - color of the node in '#rrggbbaa' or '#rgb' format.\n */\n      function webglSquare(size, color) {\n        return {\n        /**\n     * Gets or sets size of the square side.\n     */\n          size: typeof size === 'number' ? size : 10,\n\n          /**\n     * Gets or sets color of the square.\n     */\n          color: parseColor(color),\n        };\n      }\n    }, { './parseColor.js': 55 }],\n    66: [function (require, module, exports) {\n    // todo: this should be generated at build time.\n      module.exports = '0.8.1';\n    }, {}],\n  }, {}, [1]))(1);\n}));\n","const Viva = require('./vivagraph');\n\nconst txNodeColor = 0x1D84B5;\nconst inputNodeColor = 0x41D3BD;\nconst outputNodeColor = 0xE8E288;\nconst mixedNodeColor = 0xA14EBF;\nconst unknownNodeColor = 0xff0000;\nconst linkColor = '#5b5b5b';\nconst bgColor = '#02003f';\n\n\nmodule.exports = {\n  getTxNodeColor() {\n    return txNodeColor;\n  },\n\n  getInputNodeColor() {\n    return inputNodeColor;\n  },\n\n  getOutputNodeColor() {\n    return outputNodeColor;\n  },\n\n  getMixedNodeColor() {\n    return mixedNodeColor;\n  },\n\n  getUnknownNodeColor() {\n    return unknownNodeColor;\n  },\n\n  getLinkColor() {\n    return linkColor;\n  },\n\n  getBgColor() {\n    return bgColor;\n  },\n\n  // Next comes the hard part - implementation of API for custom shader\n  // program, used by webgl renderer:\n  buildCircleNodeShader() {\n  // For each primitive we need 4 attributes: x, y, color and size.\n    let ATTRIBUTES_PER_PRIMITIVE = 4,\n      nodesFS = [\n        'precision mediump float;',\n        'varying vec4 color;',\n        'void main(void) {',\n        '   if ((gl_PointCoord.x - 0.5) * (gl_PointCoord.x - 0.5) + (gl_PointCoord.y - 0.5) * (gl_PointCoord.y - 0.5) < 0.25) {',\n        '     gl_FragColor = color;',\n        '   } else {',\n        '     gl_FragColor = vec4(0);',\n        '   }',\n        '}'].join('\\n'),\n      nodesVS = [\n        'attribute vec2 a_vertexPos;',\n        // Pack color and size into vector. First elemnt is color, second - size.\n        // Since it's floating point we can only use 24 bit to pack colors...\n        // thus alpha channel is dropped, and is always assumed to be 1.\n        'attribute vec2 a_customAttributes;',\n        'uniform vec2 u_screenSize;',\n        'uniform mat4 u_transform;',\n        'varying vec4 color;',\n        'void main(void) {',\n        '   gl_Position = u_transform * vec4(a_vertexPos/u_screenSize, 0, 1);',\n        '   gl_PointSize = a_customAttributes[1] * u_transform[0][0];',\n        '   float c = a_customAttributes[0];',\n        '   color.b = mod(c, 256.0); c = floor(c/256.0);',\n        '   color.g = mod(c, 256.0); c = floor(c/256.0);',\n        '   color.r = mod(c, 256.0); c = floor(c/256.0); color /= 255.0;',\n        '   color.a = 1.0;',\n        '}'].join('\\n');\n    let program,\n      gl,\n      buffer,\n      locations,\n      utils,\n      nodes = new Float32Array(64),\n      nodesCount = 0,\n      canvasWidth,\n      canvasHeight,\n      transform,\n      isCanvasDirty;\n    return {\n    /**\n                 * Called by webgl renderer to load the shader into gl context.\n                 */\n      load(glContext) {\n        gl = glContext;\n        webglUtils = Viva.Graph.webgl(glContext);\n        program = webglUtils.createProgram(nodesVS, nodesFS);\n        gl.useProgram(program);\n        locations = webglUtils.getLocations(program, ['a_vertexPos', 'a_customAttributes', 'u_screenSize', 'u_transform']);\n        gl.enableVertexAttribArray(locations.vertexPos);\n        gl.enableVertexAttribArray(locations.customAttributes);\n        buffer = gl.createBuffer();\n      },\n      /**\n                 * Called by webgl renderer to update node position in the buffer array\n                 *\n                 * @param nodeUI - data model for the rendered node (WebGLCircle in this case)\n                 * @param pos - {x, y} coordinates of the node.\n                 */\n      position(nodeUI, pos) {\n        const idx = nodeUI.id;\n        nodes[idx * ATTRIBUTES_PER_PRIMITIVE] = pos.x;\n        nodes[idx * ATTRIBUTES_PER_PRIMITIVE + 1] = -pos.y;\n        nodes[idx * ATTRIBUTES_PER_PRIMITIVE + 2] = nodeUI.color;\n        nodes[idx * ATTRIBUTES_PER_PRIMITIVE + 3] = nodeUI.size;\n      },\n      /**\n                 * Request from webgl renderer to actually draw our stuff into the\n                 * gl context. This is the core of our shader.\n                 */\n      render() {\n        gl.useProgram(program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, nodes, gl.DYNAMIC_DRAW);\n        if (isCanvasDirty) {\n          isCanvasDirty = false;\n          gl.uniformMatrix4fv(locations.transform, false, transform);\n          gl.uniform2f(locations.screenSize, canvasWidth, canvasHeight);\n        }\n        gl.vertexAttribPointer(locations.vertexPos, 2, gl.FLOAT, false, ATTRIBUTES_PER_PRIMITIVE * Float32Array.BYTES_PER_ELEMENT, 0);\n        gl.vertexAttribPointer(locations.customAttributes, 2, gl.FLOAT, false, ATTRIBUTES_PER_PRIMITIVE * Float32Array.BYTES_PER_ELEMENT, 2 * 4);\n        gl.drawArrays(gl.POINTS, 0, nodesCount);\n      },\n      /**\n                 * Called by webgl renderer when user scales/pans the canvas with nodes.\n                 */\n      updateTransform(newTransform) {\n        transform = newTransform;\n        isCanvasDirty = true;\n      },\n      /**\n                 * Called by webgl renderer when user resizes the canvas with nodes.\n                 */\n      updateSize(newCanvasWidth, newCanvasHeight) {\n        canvasWidth = newCanvasWidth;\n        canvasHeight = newCanvasHeight;\n        isCanvasDirty = true;\n      },\n      /**\n                 * Called by webgl renderer to notify us that the new node was created in the graph\n                 */\n      createNode(node) {\n        nodes = webglUtils.extendArray(nodes, nodesCount, ATTRIBUTES_PER_PRIMITIVE);\n        nodesCount += 1;\n      },\n      /**\n                 * Called by webgl renderer to notify us that the node was removed from the graph\n                 */\n      removeNode(node) {\n        if (nodesCount > 0) { nodesCount -= 1; }\n        if (node.id < nodesCount && nodesCount > 0) {\n        // we do not really delete anything from the buffer.\n        // Instead we swap deleted node with the \"last\" node in the\n        // buffer and decrease marker of the \"last\" node. Gives nice O(1)\n        // performance, but make code slightly harder than it could be:\n          webglUtils.copyArrayPart(nodes, node.id * ATTRIBUTES_PER_PRIMITIVE, nodesCount * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n        }\n      },\n      /**\n                 * This method is called by webgl renderer when it changes parts of its\n                 * buffers. We don't use it here, but it's needed by API (see the comment\n                 * in the removeNode() method)\n                 */\n      replaceProperties(replacedNode, newNode) {},\n    };\n  },\n\n};\n"],"sourceRoot":""}